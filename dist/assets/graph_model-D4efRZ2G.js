import{o as f,g as m,E as b,A as xn,h as An,a as d,i as ze,j as Cn,k as Pn,l as Fn,n as Ln,p as zn,q as Rn,u as Vn,v as Bn,w as G,x as jn,y as Wn,z as Ne,r as T,B as re,C as qn,c as B,D as Kn,F as rt,G as Fe,H as Hn,I as Un,S as Gn,J as Jn,b as j,m as v,f as Ue,K as Yn,L as Xn,M as Qn,N as Zn,O as Mn,P as er,Q as dt,R as tr,U as Re,V as sr,W as nr,X as rr,Y as ar,Z as or,_ as ir,$ as ur,a0 as cr,a1 as lr,a2 as pr,a3 as mr,a4 as hr,a5 as dr,a6 as q,a7 as fr,a8 as st,a9 as yr,e as H,aa as Kt,ab as gr,ac as br,ad as Nr,ae as wr,af as Tr,ag as Ht,ah as ft,ai as ee,aj as L,ak as vt,al as Ut,am as A,an as yt,ao as Sr,ap as $r,aq as _r,ar as kr,as as Be,at as Er,au as vr,av as Or,aw as Ir,ax as Dr,ay as xr,az as Ar,aA as Cr,aB as Pr,aC as Fr,aD as Lr,aE as Ps,aF as zr,aG as Rr,aH as Vr,aI as Br,aJ as jr,aK as he,s as I,aL as Wr,aM as qr,aN as Kr,aO as be,aP as Hr,aQ as Ur,aR as Gr,aS as Jr,aT as Yr,aU as we,aV as gt,aW as Ve,aX as Xr,T as _e,aY as Qr,aZ as Zr,a_ as Mr,a$ as ea,b0 as ta,b1 as sa,b2 as na,b3 as ra,b4 as aa,b5 as oa,b6 as ia,b7 as ua,b8 as ca,b9 as la,ba as pa,bb as ma,bc as ha,bd as da,be as fa,bf as ya,bg as ga,bh as fs,bi as ba,bj as Na,bk as wa,bl as Ta,bm as Sa,bn as $a,bo as _a,bp as ka,bq as Ea,br as va,bs as Oa,bt as Ia,bu as je,bv as We,bw as qe,bx as Fs,by as Da,bz as xa,bA as Aa,bB as Ca,bC as Pa,bD as Fa,bE as ae,t as ne,bF as _t,bG as La,bH as za,bI as Ra,bJ as Va,bK as Ba,bL as ke,bM as ja,bN as Gt,bO as Jt,bP as Ls,bQ as ys,bR as Yt,bS as zs,bT as Xt,bU as Wa,bV as qa,bW as gs,bX as bs,bY as Ka,bZ as Ha,b_ as Ua,b$ as Ga,c0 as Ja,c1 as Ya,c2 as Xa,c3 as Qa,c4 as Za,c5 as Ma,c6 as eo,c7 as to,d as Rs,c8 as Qt,c9 as so,ca as no,cb as ro,cc as ao,cd as oo,ce as io,cf as uo,cg as co,ch as Zt,ci as Ns,cj as Mt,ck as ue,cl as bt,cm as Vs,cn as es,co as lo,cp as Bs,cq as at,cr as po,cs as mo,ct as js,cu as ho,cv as fo,cw as Ws,cx as yo,cy as go,cz as bo,cA as No,cB as wo,cC as To,cD as qs,cE as Ks,cF as ws,cG as So,cH as $o,cI as _o,cJ as ko,cK as Eo,cL as vo,cM as Oo,cN as Io,cO as Do,cP as xo,cQ as me,cR as ot}from"./index-D3B-3C1D.js";import{s as ts}from"./index-DToP8jdU.js";function Ao(s){const t={x:m(s,"x","acos")};return b.runKernel(xn,t)}const Co=f({acos_:Ao});function Po(s){const t={x:m(s,"x","acosh")};return b.runKernel(An,t)}const Fo=f({acosh_:Po});function Lo(s){d(Array.isArray(s),()=>"The argument passed to tf.addN() must be a list of tensors"),d(s.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${s.length}`);const e=s.map((r,a)=>m(r,`tensors${a}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!ze(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const n=e;return b.runKernel(Cn,n)}const zo=f({addN_:Lo});function Ro(s,e=null,t=!1){const r={x:m(s,"x","all","bool")},a={axis:e,keepDims:t};return b.runKernel(Pn,r,a)}const Vo=f({all_:Ro});function Bo(s,e=null,t=!1){const r={x:m(s,"x","any","bool")},a={axis:e,keepDims:t};return b.runKernel(Fn,r,a)}const jo=f({any_:Bo});function Wo(s,e=0){const n={x:m(s,"x","argMax")},r={axis:e};return b.runKernel(Ln,n,r)}const qo=f({argMax_:Wo});function Ko(s,e=0){const n={x:m(s,"x","argMin")},r={axis:e};return b.runKernel(zn,n,r)}const Ho=f({argMin_:Ko});function Uo(s){const t={x:m(s,"x","asin")};return b.runKernel(Rn,t)}const Go=f({asin_:Uo});function Jo(s){const t={x:m(s,"x","asinh")};return b.runKernel(Vn,t)}const Yo=f({asinh_:Jo});function Xo(s){const t={x:m(s,"x","atan")};return b.runKernel(Bn,t)}const Qo=f({atan_:Xo});function Zo(s,e){let t=m(s,"a","atan2"),n=m(e,"b","atan2");[t,n]=G(t,n);const r={a:t,b:n};return b.runKernel(jn,r)}const Mo=f({atan2_:Zo});function ei(s){const t={x:m(s,"x","atanh")};return b.runKernel(Wn,t)}const ti=f({atanh_:ei});function si(s,e,t,n,r){const a=m(s,"x","avgPool","float32"),o=1;d(Ne(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let i=a,c=!1;a.rank===3&&(c=!0,i=T(a,[1,a.shape[0],a.shape[1],a.shape[2]])),d(i.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${i.rank}.`),re("avgPool",n,r);const l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:r};let h=b.runKernel(qn,l,p);return h=B(h,a.dtype),c?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Hs=f({avgPool_:si});function ni(s,e,t,n,r,a="NDHWC"){const o=m(s,"x","avgPool3d","float32");let i=o,c=!1;o.rank===4&&(c=!0,i=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),d(i.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${i.rank}.`),d(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),d(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),re("avgPool3d",n,r);const l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:r,dataFormat:a};let h=b.runKernel(Kn,l,p);return h=B(h,i.dtype),c?T(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const ri=f({avgPool3d_:ni});function ai(s,e=0){d(s.length>=1,()=>"Pass at least one tensor to concat");const t=rt(s,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return Fe(t[0]);const n=t,r={axis:e};return b.runKernel(Hn,n,r)}const U=f({concat_:ai});function oi(s,e,t=!1,n=!1){let r=m(s,"a","matMul"),a=m(e,"b","matMul");[r,a]=G(r,a);const o={a:r,b:a},i={transposeA:t,transposeB:n};return b.runKernel(Un,o,i)}const x=f({matMul_:oi});function ii(s,e,t){const n=m(s,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");const r={x:n},a={begin:e,size:t};return b.runKernel(Gn,r,a)}const C=f({slice_:ii});function ui(s){const t={x:m(s,"x","tanh","float32")};return b.runKernel(Jn,t)}const Ot=f({tanh_:ui});function ci(s,e,t,n,r,a){const o=m(s,"forgetBias","basicLSTMCell"),i=m(e,"lstmKernel","basicLSTMCell"),c=m(t,"lstmBias","basicLSTMCell"),l=m(n,"data","basicLSTMCell"),p=m(r,"c","basicLSTMCell"),h=m(a,"h","basicLSTMCell"),y=U([l,h],1),g=x(y,i),w=j(g,c),S=w.shape[0],N=w.shape[1]/4,$=[S,N],E=C(w,[0,0],$),O=C(w,[0,N],$),_=C(w,[0,N*2],$),D=C(w,[0,N*3],$),k=j(v(Ue(E),Ot(O)),v(p,Ue(j(o,_)))),P=v(Ot(k),Ue(D));return[k,P]}const li=f({basicLSTMCell_:ci});function pi(s,e,t){const n=m(s,"x","batchToSpaceND"),r=e.reduce((i,c)=>i*c);d(n.rank>=1+e.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${e.length}`),d(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),d(n.shape[0]%r===0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const a={x:n},o={blockShape:e,crops:t};return b.runKernel(Yn,a,o)}const Us=f({batchToSpaceND_:pi});function mi(s){let e;return s.rank===0||s.rank===1?e=T(s,[1,1,1,s.size]):s.rank===2?e=T(s,[1,1,s.shape[0],s.shape[1]]):s.rank===3?e=T(s,[1,s.shape[0],s.shape[1],s.shape[2]]):e=s,e}function hi(s,e,t,n,r,a){a==null&&(a=.001);const o=m(s,"x","batchNorm"),i=m(e,"mean","batchNorm"),c=m(t,"variance","batchNorm");let l;r!=null&&(l=m(r,"scale","batchNorm"));let p;n!=null&&(p=m(n,"offset","batchNorm")),d(i.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),d(p==null||i.rank===p.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),d(l==null||i.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const y={x:mi(o),scale:l,offset:p,mean:i,variance:c},g={varianceEpsilon:a},w=b.runKernel(Xn,y,g);return T(w,o.shape)}const Nt=f({batchNorm_:hi});function di(s,e,t,n,r,a){const o=m(s,"x","batchNorm"),i=m(e,"mean","batchNorm"),c=m(t,"variance","batchNorm");let l;r!=null&&(l=m(r,"scale","batchNorm"));let p;return n!=null&&(p=m(n,"offset","batchNorm")),d(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),d(i.rank===2||i.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${i.rank}.`),d(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&d(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),p!=null&&d(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${p.rank}.`),Nt(o,i,c,p,l,a)}const fi=f({batchNorm2d_:di});function yi(s,e,t,n,r,a){const o=m(s,"x","batchNorm"),i=m(e,"mean","batchNorm"),c=m(t,"variance","batchNorm");let l;r!=null&&(l=m(r,"scale","batchNorm"));let p;return n!=null&&(p=m(n,"offset","batchNorm")),d(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),d(i.rank===3||i.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${i.rank}.`),d(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&d(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),p!=null&&d(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${p.rank}.`),Nt(o,i,c,p,l,a)}const gi=f({batchNorm3d_:yi});function bi(s,e,t,n,r,a){const o=m(s,"x","batchNorm"),i=m(e,"mean","batchNorm"),c=m(t,"variance","batchNorm");let l;r!=null&&(l=m(r,"scale","batchNorm"));let p;return n!=null&&(p=m(n,"offset","batchNorm")),d(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),d(i.rank===4||i.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${i.rank}.`),d(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&d(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),p!=null&&d(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${p.rank}.`),Nt(o,i,c,p,l,a)}const Ni=f({batchNorm4d_:bi});function wi(s,e,t){const n=m(s,"x","bincount"),r=m(e,"weights","bincount");d(n.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${n.dtype}`),d(t>=0,()=>`size must be non-negative, but got ${t}.`),d(r.size===n.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${n.shape}, weights shape: ${r.shape}.`);const a={x:n,weights:r},o={size:t};return b.runKernel(Qn,a,o)}const Gs=f({bincount_:wi});function Ti(s,e){const t=m(s,"x","bitwiseAnd"),n=m(e,"y","bitwiseAnd");if(!ze(t.shape,n.shape))throw new Error(`BitwiseAnd: Tensors must have the same shape. x: ${t.shape}, y: ${n.shape}`);if(t.dtype!=="int32"||n.dtype!=="int32")throw new Error(`BitwiseAnd: Only supports 'int32' values in tensor, found type of x: ${t.dtype} and type of y: ${n.dtype}`);const r={a:t,b:n};return b.runKernel(Zn,r)}const Si=f({bitwiseAnd_:Ti});function $i(s,e){const t=m(s,"s0","broadcastArgs","int32"),n=m(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(n.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${n.rank}`);const r={s0:t,s1:n};return b.runKernel(Mn,r)}const _i=f({broadcastArgs_:$i});function ki(s){const t={x:m(s,"x","ceil","float32")};return b.runKernel(er,t)}const Ei=f({ceil_:ki});function vi(s,e,t){const n=m(s,"x","clipByValue");if(d(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return dt(n.shape,e,n.dtype);const r={x:n},a={clipValueMin:e,clipValueMax:t};return b.runKernel(tr,r,a)}const Oi=f({clipByValue_:vi});function Ii(s){return U(s,0)}const Di=f({concat1d_:Ii});function xi(s,e){return U(s,e)}const Ai=f({concat2d_:xi});function Ci(s,e){return U(s,e)}const Pi=f({concat3d_:Ci});function Fi(s,e){return U(s,e)}const Li=f({concat4d_:Fi});function zi(s,e,t,n,r="NHWC",a=[1,1],o){const i=m(s,"x","conv2d","float32"),c=m(e,"filter","conv2d","float32");let l=i,p=!1;i.rank===3&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),d(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),d(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),re("conv2d",n,o);const h=r==="NHWC"?l.shape[3]:l.shape[1];d(h===c.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${c.shape[2]}.`),d(Ne(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),d(Re(a),()=>"Error in conv2D: Dilated rates should be larger than 0."),d(Re(t),()=>"Error in conv2D: Strides should be larger than 0.");const y={x:l,filter:c},g={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o},w=b.runKernel(sr,y,g);return p?T(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const wt=f({conv2d_:zi});function Ri(s,e,t,n,r="NWC",a=1,o){const i=m(s,"x","conv1d"),c=m(e,"filter","conv1d");let l=i,p=!1;i.rank===2&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1]])),d(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),d(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),re("conv1d",n,o),d(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),d(Ne(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),d(Re(a),()=>"Error in conv1D: Dilated rates should be larger than 0."),d(Re(t),()=>"Error in conv1D: Stride should be larger than 0."),d(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=T(c,[1,c.shape[0],c.shape[1],c.shape[2]]),y=T(l,[l.shape[0],1,l.shape[1],l.shape[2]]),N=wt(y,h,[1,t],n,"NHWC",[1,a],o);return p?T(N,[N.shape[2],N.shape[3]]):T(N,[N.shape[0],N.shape[2],N.shape[3]])}const Vi=f({conv1d_:Ri});function Bi(s,e,t,n,r,a="NHWC",o){d(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let i=s,c=e,l=!1;e.rank===3&&(l=!0,c=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]),i=[1,s[0],s[1],s[2]]),d(i.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${i.length}.`),d(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),d(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const p=a==="NHWC"?i[3]:i[1],h=a==="NHWC"?c.shape[3]:c.shape[1];d(p===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${p}) must match input depth for filter ${t.shape[2]}.`),d(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),re("conv2dDerInput",r,o);const y={dy:c,filter:t},g={strides:n,pad:r,dataFormat:a,dimRoundingMode:o,inputShape:i},w=b.runKernel(nr,y,g);return l?T(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const Js=f({conv2DBackpropInput_:Bi});function ji(s,e,t,n,r,a){const o=m(s,"x","conv2dTranspose"),i=m(e,"filter","conv2dTranspose");return Js(t,o,i,n,r,"NHWC",a)}const Wi=f({conv2dTranspose_:ji});function qi(s,e,t,n,r="NDHWC",a=[1,1,1]){const o=m(s,"x","conv3d"),i=m(e,"filter","conv3d");let c=o,l=!1;o.rank===4&&(l=!0,c=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),d(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),d(i.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${i.rank}.`),d(c.shape[4]===i.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${i.shape[3]}.`),d(Ne(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),d(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`),d(Re(a),()=>"Error in conv3D: Dilated rates should be larger than 0."),d(Re(t),()=>"Error in conv3D: Strides should be larger than 0.");const p={x:c,filter:i},h={strides:t,pad:n,dataFormat:r,dilations:a},y=b.runKernel(rr,p,h);return l?T(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Ki=f({conv3d_:qi});function Hi(s,e,t,n,r){d(s.length===e.rank,()=>`Length of inShape (${s.length}) and rank of dy (${e.rank}) must match`);let a=s,o=e,i=!1;e.rank===4&&(i=!0,o=T(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,s[0],s[1],s[2],s[3]]);const c=a[4],l=o.shape[4];d(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),d(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),d(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),d(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),d(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const p={dy:o,filter:t},h={pad:r,strides:n,inputShape:a},y=b.runKernel(ar,p,h);return i?T(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}const Ui=f({conv3DBackpropInput_:Hi});function Gi(s,e,t,n,r){const a=m(s,"x","conv3dTranspose"),o=m(e,"filter","conv3dTranspose");return Ui(t,a,o,n,r)}const Ji=f({conv3dTranspose_:Gi});function Yi(s){const t={x:m(s,"x","cos","float32")};return b.runKernel(or,t)}const Xi=f({cos_:Yi});function Qi(s){const t={x:m(s,"x","cosh","float32")};return b.runKernel(ir,t)}const Zi=f({cosh_:Qi});function Mi(s,e=0,t=!1,n=!1){const a={x:m(s,"x","cumprod")},o={axis:e,exclusive:t,reverse:n};return b.runKernel(ur,a,o)}const eu=f({cumprod_:Mi});function tu(s,e=0,t=!1,n=!1){const a={x:m(s,"x","cumsum")},o={axis:e,exclusive:t,reverse:n};return b.runKernel(cr,a,o)}const su=f({cumsum_:tu});function nu(s,e,t,n=!1){const r=m(s,"x","denseBincount"),a=m(e,"weights","denseBincount");d(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),d(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),d(t>=0,()=>`size must be non-negative, but got ${t}.`),d(a.size===r.size||a.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${a.shape}.`);const o={x:r,weights:a},i={size:t,binaryOutput:n};return b.runKernel(lr,o,i)}const ru=f({denseBincount_:nu});function au(s,e,t="NHWC"){const n=m(s,"x","depthToSpace","float32"),r=t==="NHWC"?n.shape[1]:n.shape[2],a=t==="NHWC"?n.shape[2]:n.shape[3],o=t==="NHWC"?n.shape[3]:n.shape[1];d(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),d(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${n.shape}`),d(a*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${a} and ${e} for depthToSpace with input shape
        ${n.shape}`),d(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${n.shape}`);const i={x:n},c={blockSize:e,dataFormat:t};return b.runKernel(pr,i,c)}const ou=f({depthToSpace_:au});function iu(s,e,t,n,r="NHWC",a=[1,1],o){const i=m(s,"x","depthwiseConv2d","float32"),c=m(e,"filter","depthwiseConv2d","float32");let l=i,p=!1;i.rank===3&&(p=!0,l=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),d(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),d(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const h=r==="NHWC"?l.shape[3]:l.shape[1];d(h===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${c.shape[2]}.`),re("depthwiseConv2d",n,o);const y={x:l,filter:c},g={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o},w=b.runKernel(mr,y,g);return p?T(w,[w.shape[1],w.shape[2],w.shape[3]]):w}const ss=f({depthwiseConv2d_:iu});function uu(s){const t={x:m(s,"x","diag")};return b.runKernel(hr,t)}const cu=f({diag_:uu});function lu(s,e,t,n,r=[1,1],a="NHWC"){const o=m(s,"x","dilation2d"),i=m(e,"filter","dilation2d");d(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),d(i.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${i.rank}.`),d(a==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${a}`);let c=o,l=!1;o.rank===3&&(c=T(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),d(c.shape[3]===i.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${i.shape[2]}`);const p={x:c,filter:i},h={strides:t,pad:n,dilations:r},y=b.runKernel(dr,p,h);return l?T(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const pu=f({dilation2d_:lu});function mu(s,e){let t=m(s,"a","equal","string_or_numeric"),n=m(e,"b","equal","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(fr,r)}const Ys=f({equal_:mu});function hu(s,e,t){const n=m(e,"a","where"),r=m(t,"b","where"),a=m(s,"condition","where","bool"),o=q(q(a.shape,n.shape),r.shape),i=st(a,o),c=st(n,o),l=st(r,o),p={condition:i,t:c,e:l};return b.runKernel(yr,p)}const ge=f({where_:hu});function du(s,e){let t=m(s,"a","div"),n=m(e,"b","div");[t,n]=G(t,n);const r=H(t,n),a=Kt(r),o=Ys(n,a);return ge(o,a,r)}const fu=f({divNoNan_:du});function yu(s,e){const t=m(s,"t1","dot"),n=m(e,"t2","dot");d((t.rank===1||t.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${n.rank}.`);const r=t.rank===1?t.size:t.shape[1],a=n.rank===1?n.size:n.shape[0];if(d(r===a,()=>`Error in dot: inner dimensions of inputs must match, but got ${r} and ${a}.`),t.rank===1&&n.rank===1){const o=T(t,[1,-1]),i=T(n,[-1,1]),c=x(o,i);return T(c,[])}else if(t.rank===1&&n.rank===2){const o=T(t,[1,-1]),i=T(n,[n.shape[0],n.shape[1]]),c=x(o,i);return T(c,[c.size])}else if(t.rank===2&&n.rank===1){const o=T(n,[-1,1]),i=x(t,o);return T(i,[i.size])}else{const o=T(n,[n.shape[0],n.shape[1]]);return x(t,o)}}const gu=f({dot_:yu});function bu(s,...e){const t=e.map((r,a)=>m(r,`tensors${a}`,"einsum")),n={equation:s};return b.runKernel(gr,t,n)}const Pe=f({einsum_:bu});function Nu(s,e){const t=m(s,"x","ensureShape","string_or_numeric");if(!br(t.shape,e))throw new Error(`EnsureShape: Shape of tensor ${t.shape} is not compatible with expected shape ${e}`);return s}const wu=f({ensureShape_:Nu});function Tu(s){let e=m(s,"x","erf");d(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=B(e,"float32"));const t={x:e};return b.runKernel(Nr,t)}const Su=f({erf_:Tu});function $u(s,e=null,t=!1){const r={x:m(s,"x","max")},a={reductionIndices:e,keepDims:t};return b.runKernel(wr,r,a)}const Le=f({max_:$u});function _u(s,e=null,t=!1){const r={x:m(s,"x","min")},a={axis:e,keepDims:t};return b.runKernel(Tr,r,a)}const It=f({min_:_u});function ku(s,e="euclidean",t=null,n=!1){s=m(s,"x","norm");const r=Xs(s,e,t);let a=r.shape;if(n){const o=Ht(t,s.shape);a=ft(r.shape,o)}return T(r,a)}function Xs(s,e,t=null){if(s.rank===0)return ee(s);if(s.rank!==1&&t===null)return Xs(T(s,[-1]),e,t);if(s.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return L(ee(s),t);if(e===1/0)return Le(ee(s),t);if(e===-1/0)return It(ee(s),t);if(e==="euclidean"||e===2)return vt(L(Ut(ee(s),A(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Le(L(ee(s),t[0]),t[1]-1);if(e===1/0)return Le(L(ee(s),t[1]),t[0]);if(e===-1/0)return It(L(ee(s),t[1]),t[0]);if(e==="fro"||e==="euclidean")return vt(L(yt(s),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Tt=f({norm_:ku});function Eu(s,e=null,t=!1){return Tt(s,"euclidean",e,t)}const vu=f({euclideanNorm_:Eu});function Ou(s){const t={x:m(s,"x","exp")};return b.runKernel(Sr,t)}const Ee=f({exp_:Ou});function Iu(s,e=0){const t=m(s,"x","expandDims","string_or_numeric");d(e<=t.rank,()=>"Axis must be <= rank of the tensor");const n={input:t},r={dim:e};return b.runKernel($r,n,r)}const ye=f({expandDims_:Iu});function Du(s){const t={x:m(s,"x","expm1")};return b.runKernel(_r,t)}const xu=f({expm1_:Du});function Au(s,e){const t=m(s,"x","tile","string_or_numeric");d(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const n={x:t},r={reps:e};return b.runKernel(kr,n,r)}const Ge=f({tile_:Au});function Cu(s,e,t,n="float32"){e==null&&(e=s);const r=Be([s,e],n),a=s<=e?s:e;for(let i=0;i<a;++i)r.set(1,i,i);const o=T(r.toTensor(),[s,e]);if(t==null)return o;if(t.length===1)return Ge(ye(o,0),[t[0],1,1]);if(t.length===2)return Ge(ye(ye(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Ge(ye(ye(ye(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Qs=f({eye_:Cu});function Pu(s){const t={x:m(s,"x","floor","float32")};return b.runKernel(Er,t)}const Zs=f({floor_:Pu});function Fu(s,e,t=0,n=0){const r=m(s,"x","gather"),a=m(e,"indices","gather","int32"),o={x:r,indices:a},i={axis:t,batchDims:n};return b.runKernel(vr,o,i)}const Ms=f({gather_:Fu});function Lu(s,e){let t=m(s,"a","greater","string_or_numeric"),n=m(e,"b","greater","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Or,r)}const St=f({greater_:Lu});function zu(s,e){let t=m(s,"a","greaterEqual","string_or_numeric"),n=m(e,"b","greaterEqual","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Ir,r)}const en=f({greaterEqual_:zu});function Ru(s){const t={input:m(s,"input","imag")};return b.runKernel(Dr,t)}const $t=f({imag_:Ru});function Vu(s){const t={x:m(s,"x","isFinite")};return b.runKernel(xr,t)}const Bu=f({isFinite_:Vu});function ju(s){const t={x:m(s,"x","isInf")};return b.runKernel(Ar,t)}const Wu=f({isInf_:ju});function qu(s){const t={x:m(s,"x","isNaN")};return b.runKernel(Cr,t)}const Ku=f({isNaN_:qu});function Hu(s,e){let t=m(s,"a","less","string_or_numeric"),n=m(e,"b","less","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Pr,r)}const Dt=f({less_:Hu});function Uu(s,e){let t=m(s,"a","lessEqual","string_or_numeric"),n=m(e,"b","lessEqual","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Fr,r)}const ns=f({lessEqual_:Uu});function Gu(s,e,t){if(t<=0)throw new Error("The number of values should be positive.");const n={start:s,stop:e,num:t};return b.runKernel(Lr,{},n)}function Ju(s,e=5,t=1,n=1,r=.5){const a=m(s,"x","localResponseNormalization");d(a.rank===4||a.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${a.rank}.`),d(Ps(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=a,i=!1;a.rank===3&&(i=!0,o=T(a,[1,a.shape[0],a.shape[1],a.shape[2]]));const c={x:o},l={depthRadius:e,bias:t,alpha:n,beta:r},p=b.runKernel(zr,c,l);return i?T(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Yu=f({localResponseNormalization_:Ju});function Xu(s){const t={x:m(s,"x","log","float32")};return b.runKernel(Rr,t)}const Ye=f({log_:Xu});function Qu(s){const t={x:m(s,"x","log1p")};return b.runKernel(Vr,t)}const tn=f({log1p_:Qu});function Zu(s){const t={x:m(s,"x","neg")};return b.runKernel(Br,t)}const ie=f({neg_:Zu});function Mu(s){const t={x:m(s,"x","softplus")};return b.runKernel(jr,t)}const sn=f({softplus_:Mu});function ec(s){const e=m(s,"x","logSigmoid");return he(n=>({value:ie(sn(ie(n))),gradFunc:o=>v(o,Ue(ie(n)))}))(e)}const tc=f({logSigmoid_:ec});function sc(s,e=-1){const t=m(s,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return he((r,a)=>{const i=Le(r,e,!0),c=I(r,i),l=I(B(c,"float32"),Ye(L(Ee(c),e,!0)));return a([l]),{value:l,gradFunc:(h,y)=>{const[g]=y,w=!0,S=Ee(g);return I(h,v(L(h,e,w),S))}}})(t)}const nc=f({logSoftmax_:sc});function rc(s,e=null,t=!1){const n=m(s,"x","logSumExp"),r=Ht(e,n.shape),a=Le(n,r,!0),o=I(n,a),i=Ee(o),c=L(i,r),l=Ye(c),p=j(T(a,l.shape),l);if(t){const h=ft(p.shape,r);return T(p,h)}return p}const nn=f({logSumExp_:rc});function ac(s,e){const t=m(s,"a","logicalAnd","bool"),n=m(e,"b","logicalAnd","bool");q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Wr,r)}const it=f({logicalAnd_:ac});function oc(s){const t={x:m(s,"x","logicalNot","bool")};return b.runKernel(qr,t)}const rn=f({logicalNot_:oc});function ic(s,e){const t=m(s,"a","logicalOr","bool"),n=m(e,"b","logicalOr","bool");q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Kr,r)}const an=f({logicalOr_:ic});function uc(s,e){const t=m(s,"a","logicalXor","bool"),n=m(e,"b","logicalXor","bool");return q(t.shape,n.shape),it(an(s,e),rn(it(s,e)))}const cc=f({logicalXor_:uc});const et=2147483648;function lc(s,e,t="left"){const n=m(s,"sortedSequence","searchSorted"),r=m(e,"values","searchSorted"),a=n.shape[n.shape.length-1],o=r.shape[r.shape.length-1],i=T(n,[-1,a]),c=T(r,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(be(c.shape)>=et)throw new Error(`values tensor size must less than ${et}`);if(i.shape[1]>=et)throw new Error(`trailing dim_size must less than ${et} for int32 output type, was ${i.shape[1]}`);const l={sortedSequence:i,values:c},p={side:t};return b.runKernel(Hr,l,p)}const rs=f({searchSorted_:lc});function pc(s,e){return rs(s,e,"left")}function mc(s,e,t,n,r){const a=m(s,"x","maxPool"),o=1;let i=a,c=!1;a.rank===3&&(c=!0,i=T(a,[1,a.shape[0],a.shape[1],a.shape[2]])),d(i.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${i.rank}.`),d(Ne(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),re("maxPool",n,r);const l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:r},h=b.runKernel(Ur,l,p);return c?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const on=f({maxPool_:mc});function hc(s,e=[1,1,1],t,n,r,a="NDHWC"){const o=m(s,"x","maxPool3d");let i=o,c=!1;o.rank===4&&(c=!0,i=T(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),d(i.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${i.rank}.`),d(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),re("maxPool3d",n,r);const l={x:i},p={filterSize:e,strides:t,pad:n,dimRoundingMode:r,dataFormat:a},h=b.runKernel(Gr,l,p);return c?T(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const dc=f({maxPool3d_:hc});function fc(s,e,t,n,r=!1){const o={x:m(s,"x","maxPoolWithArgmax")},i={filterSize:e,strides:t,pad:n,includeBatchInIndex:r},c=b.runKernel(Jr,o,i);return{result:c[0],indexes:c[1]}}const yc=f({maxPoolWithArgmax_:fc});function gc(s,e=null,t=!1){const r={x:m(s,"x","mean")},a={axis:e,keepDims:t};return b.runKernel(Yr,r,a)}const ut=f({mean_:gc});function $e(s,e="float32"){if(we(s),e==="complex64"){const n=$e(s,"float32"),r=gt(s,"float32");return Ve(n,r)}const t=Xr(be(s),e);return b.makeTensor(t,s,e)}function bc(s,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(s===void 0)return[];let n=m(s,"x","meshgrid",s instanceof _e?s.dtype:"float32");if(e===void 0)return[n];let r=m(e,"y","meshgrid",e instanceof _e?e.dtype:"float32");const a=be(n.shape),o=be(r.shape);return t==="xy"?(n=T(n,[1,-1]),r=T(r,[-1,1]),[x($e([o,1],n.dtype),n),x(r,$e([1,a],r.dtype))]):(n=T(n,[-1,1]),r=T(r,[1,-1]),[x(n,$e([1,o],n.dtype)),x($e([a,1],r.dtype),r)])}function Nc(s,e){let t=m(s,"a","minimum"),n=m(e,"b","minimum");[t,n]=G(t,n),t.dtype==="bool"&&(t=B(t,"int32"),n=B(n,"int32")),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(Qr,r)}const ct=f({minimum_:Nc});function wc(s,e,t){d(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const n=m(s,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");d(e.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let i=0;i<n.rank;i++)d(e[i].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),d(e[i][0]>=0&&e[i][0]<=n.shape[i]-r&&e[i][1]>=0&&e[i][1]<=n.shape[i]-r,()=>`Padding in dimension ${i} cannot be greater than or equal to ${n.shape[i]-r} or less than 0 for input of shape ${n.shape}`);const a={paddings:e,mode:t},o={x:n};return b.runKernel(Zr,o,a)}const Tc=f({mirrorPad_:wc});function Sc(s,e){let t=m(s,"a","mod"),n=m(e,"b","mod");[t,n]=G(t,n);const r={a:t,b:n};return b.runKernel(Mr,r)}const $c=f({mod_:Sc});function _c(s,e=null,t=!1){s=m(s,"x","moments");const n=Ht(e,s.shape),r=ut(s,n,t);let a=r.shape;t||(a=ft(r.shape,n));const o=yt(I(B(s,"float32"),T(r,a))),i=ut(o,n,t);return{mean:r,variance:i}}const kc=f({moments_:_c});function Ec(s,e,t,n){const r=m(e,"data","multiRNNCell"),a=rt(t,"c","multiRNNCell"),o=rt(n,"h","multiRNNCell");let i=r;const c=[];for(let h=0;h<s.length;h++){const y=s[h](i,a[h],o[h]);c.push(y[0]),c.push(y[1]),i=y[1]}const l=[],p=[];for(let h=0;h<c.length;h+=2)l.push(c[h]),p.push(c[h+1]);return[l,p]}const vc=f({multiRNNCell_:Ec});function Oc(s,e,t,n=!1){const r=m(s,"logits","multinomial"),a=r.size,o=r.rank;if(a<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${a}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const c={logits:o===1?T(r,[1,-1]):r},l={numSamples:e,seed:t,normalized:n},p=b.runKernel(ea,c,l);return o===1?T(p,[p.size]):p}const Ic=f({multinomial_:Oc});function Dc(s,e){let t=m(s,"a","notEqual","string_or_numeric"),n=m(e,"b","notEqual","string_or_numeric");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n};return b.runKernel(ta,r)}const un=f({notEqual_:Dc});function xc(s,e,t=1,n=0,r="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:m(s,"indices","oneHot","int32")},i={dtype:r,depth:e,onValue:t,offValue:n};return b.runKernel(sa,o,i)}const Ac=f({oneHot_:xc});function Cc(s){const t={x:m(s,"x","onesLike")};return b.runKernel(na,t)}const Pc=f({onesLike_:Cc});function Fc(s,e){const t=m(s,"v1","outerProduct"),n=m(e,"v2","outerProduct");d(t.rank===1&&n.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${n.rank}.`);const r=T(t,[-1,1]),a=T(n,[1,-1]);return x(r,a)}const Lc=f({outerProduct_:Fc});function zc(s,e,t=0){const n=m(s,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},a={x:n};return b.runKernel(ra,a,r)}const Me=f({pad_:zc});function Rc(s,e,t=0){return d(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),Me(s,[e],t)}const Vc=f({pad1d_:Rc});function Bc(s,e,t=0){return d(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Me(s,e,t)}const jc=f({pad2d_:Bc});function Wc(s,e,t=0){return d(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Me(s,e,t)}const qc=f({pad3d_:Wc});function Kc(s,e,t=0){return d(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Me(s,e,t)}const Hc=f({pad4d_:Kc});function Uc(s,e,t){const n=m(s,"x","spaceToBatchND");d(n.rank>=1+e.length,()=>`input rank ${n.rank} should be > than [blockShape] ${e.length}`),d(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),d(n.shape.reduce((o,i,c)=>c>0&&c<=e.length?o&&(i+t[c-1][0]+t[c-1][1])%e[c-1]===0:o,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:n},a={blockShape:e,paddings:t};return b.runKernel(aa,r,a)}const cn=f({spaceToBatchND_:Uc});function Gc(s,e,t,n,r,a,o){r==null&&(r=[1,1]),a==null&&(a=1),n===0&&(n="valid");const i=m(s,"x","maxPool");let c=i,l=!1;i.rank===3&&(l=!0,c=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),d(Ne(a,r),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${a} and dilations '${r}'`);const p=oa(c.shape,e,a,r,n),h=[p.dilationHeight,p.dilationWidth];let y;n==="same"?y=Yc([p.filterHeight,p.filterWidth],h):y=[[0,0],[0,0]];const g=h[0]===1&&h[1]===1,[w,S]=Jc([p.inHeight,p.inWidth],h,y),N=g?n:"valid",$=g?c:cn(c,h,w),O=(t==="avg"?()=>Hs($,e,a,N,o):()=>on($,e,a,N,o))(),_=g?O:Us(O,h,S);return l?T(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function Jc(s,e,t){const n=t.map(p=>p[0]),r=t.map(p=>p[1]),a=s.concat(n,r),o=e.map((p,h)=>(p-a[h]%p)%p),i=r.map((p,h)=>p+o[h]),c=e.map((p,h)=>[n[h],i[h]]),l=e.map((p,h)=>[0,o[h]]);return[c,l]}function Yc(s,e){const n=s.map((o,i)=>o+(o-1)*(e[i]-1)).map(o=>o-1),r=n.map(o=>Math.floor(o/2)),a=n.map((o,i)=>o-r[i]);return n.map((o,i)=>[r[i],a[i]])}const Xc=f({pool_:Gc});function Qc(s,e=null,t=!1){let n=m(s,"x","prod");n.dtype==="bool"&&(n=B(n,"int32"));const r={x:n},a={axis:e,keepDims:t};return b.runKernel(ia,r,a)}const Zc=f({prod_:Qc});function Mc(s,e,t,n){const r=s.map((p,h)=>m(p,`tensors${h}`,"raggedGather","int32")),a=m(e,"paramsDenseValues","raggedGather"),o=m(t,"indices","raggedGather","int32"),i={paramsNestedSplits:r,paramsDenseValues:a,indices:o},c={outputRaggedRank:n},l=b.runKernel(ua,i,c);return{outputNestedSplits:l.slice(0,l.length-1),outputDenseValues:l[l.length-1]}}const el=f({raggedGather_:Mc});function tl(s,e,t){const n=m(s,"starts","raggedRange"),r=m(e,"limits","raggedRange",n.dtype),a=m(t,"deltas","raggedRange",n.dtype),o={starts:n,limits:r,deltas:a},i=b.runKernel(ca,o);return{rtNestedSplits:i[0],rtDenseValues:i[1]}}const sl=f({raggedRange_:tl});function nl(s,e,t,n,r){const a=m(s,"shape","raggedTensorToTensor","int32"),o=m(e,"values","raggedTensorToTensor"),i=m(t,"defaultValue","raggedTensorToTensor",o.dtype),c=n.map((h,y)=>m(h,`tensors${y}`,"raggedTensorToTensor","int32")),l={shape:a,values:o,defaultValue:i,rowPartitionTensors:c},p={rowPartitionTypes:r};return b.runKernel(la,l,p)}const rl=f({raggedTensorToTensor_:nl});function al(s,e,t){we(s);const n=be(s);let r=null;if(t==null||t==="float32")r=new Float32Array(n);else if(t==="int32")r=new Int32Array(n);else if(t==="bool")r=new Uint8Array(n);else throw new Error(`Unknown data type ${t}`);for(let a=0;a<n;a++)r[a]=e();return b.makeTensor(r,s,t)}const ol=f({rand_:al});class as{constructor(e,t,n,r,a){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=a||Math.random();this.random=ts.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,n=!1;for(;!n;){let r,a,o;do r=2*this.random()-1,a=2*this.random()-1,o=r*r+a*a;while(o>=1||o===0);const i=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*i,t=this.mean+this.stdDev*a*i,(!this.truncated||this.isValidTruncated(e))&&(n=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class il{constructor(e,t,n,r){this.alpha=e,this.beta=1/t,this.dtype=n;const a=r||Math.random();this.randu=ts.alea(a.toString()),this.randn=new as(0,1,n,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,r,a,o;for(;;){do r=this.randn.nextValue(),o=1+this.c*r;while(o<=0);if(o*=o*o,e=r*r,t=1-.331*e*e,n=.5*e+this.d*(1-o+Math.log(o)),a=this.randu(),a<t||Math.log(a)<n)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class ul{constructor(e=0,t=1,n,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=n,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=ts.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function cl(s,e,t=1,n="float32",r){if(we(s),t==null&&(t=1),n==null&&(n="float32"),n!=="float32"&&n!=="int32")throw new Error(`Unsupported data type ${n}`);const a=new il(e,t,n,r),o=Be(s,n);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const ll=f({randomGamma_:cl});function pl(s,e=0,t=1,n,r){if(we(s),n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);const a=new as(e,t,n,!1,r),o=Be(s,n);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const ln=f({randomNormal_:pl});function ml(s,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ln(s,0,1,e,t)}const hl=f({randomStandardNormal_:ml});function dl(s,e=0,t=1,n="float32",r){we(s);const a=Be(s,n),o=new ul(e,t,null,r);for(let i=0;i<a.values.length;i++)a.values[i]=o.nextValue();return a.toTensor()}const os=f({randomUniform_:dl});function fl(s,e,t,n){return os(s,e,t,"int32",n)}const yl=f({randomUniformInt_:fl});function Xe(s,e,t=1,n="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:s,stop:e,step:t,dtype:n};return b.runKernel(pa,{},r)}function gl(s){const t={input:m(s,"input","real")};return b.runKernel(ma,t)}const Qe=f({real_:gl});function bl(s){const t={x:m(s,"x","reciprocal")};return b.runKernel(ha,t)}const Nl=f({reciprocal_:bl});function wl(s,e){const n={x:m(s,"x","reverse")},r={dims:e};return b.runKernel(da,n,r)}const ve=f({reverse_:wl});function Tl(s){const e=m(s,"x","reverse");return d(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ve(e,0)}const Sl=f({reverse1d_:Tl});function $l(s,e){const t=m(s,"x","reverse");return d(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),ve(t,e)}const _l=f({reverse2d_:$l});function kl(s,e){const t=m(s,"x","reverse");return d(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),ve(t,e)}const El=f({reverse3d_:kl});function vl(s,e){const t=m(s,"x","reverse");return d(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),ve(t,e)}const Ol=f({reverse4d_:vl});function Il(s){const t={x:m(s,"x","round")};return b.runKernel(fa,t)}const pn=f({round_:Il});function Dl(s){const t={x:m(s,"x","rsqrt","float32")};return b.runKernel(ya,t)}const xl=f({rsqrt_:Dl});function Al(s){const t={x:m(s,"x","selu")};return b.runKernel(ga,t)}const Cl=f({selu_:Al});function Pl(s,e,t,n,r,a=[1,1],o="NHWC"){const i=m(s,"x","separableConv2d"),c=m(e,"depthwiseFilter","separableConv2d"),l=m(t,"pointwiseFilter","separableConv2d");let p=i,h=!1;if(i.rank===3&&(h=!0,p=T(i,[1,i.shape[0],i.shape[1],i.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");d(p.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${p.rank}.`),d(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),d(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),d(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),d(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const y=c.shape[2],g=c.shape[3];d(l.shape[2]===y*g,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${y*g}, but got ${l.shape[2]}.`);const w=ss(p,c,n,r,o,a),N=wt(w,l,1,"valid",o);return h?T(N,[N.shape[1],N.shape[2],N.shape[3]]):N}const Fl=f({separableConv2d_:Pl});async function Ll(s,e){const t=m(s,"x","setdiff1d"),n=m(e,"y","setdiff1d");d(t.dtype===n.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${n.dtype}).`),d(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),d(n.rank===1,()=>`y should be 1D tensor, but got y (${n.shape}).`);const r=await t.data(),a=await n.data(),o=new Set(a);let i=0;for(let p=0;p<r.length;p++)o.has(r[p])||i++;const c=new fs([i],t.dtype),l=new fs([i],"int32");for(let p=0,h=0;p<r.length;p++)o.has(r[p])||(c.values[h]=r[p],l.values[h]=p,h++);return[c.toTensor(),l.toTensor()]}const zl=Ll;function Rl(s){const t={x:m(s,"x","sign")};return b.runKernel(ba,t)}const Vl=f({sign_:Rl});function Bl(s){const t={x:m(s,"x","sin","float32")};return b.runKernel(Na,t)}const jl=f({sin_:Bl});function Wl(s){const t={x:m(s,"x","sinh")};return b.runKernel(wa,t)}const ql=f({sinh_:Wl});function Kl(s,e,t){const n=m(s,"x","slice1d");return d(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),C(n,[e],[t])}const Hl=f({slice1d_:Kl});function Ul(s,e,t){const n=m(s,"x","slice2d");return d(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),C(n,e,t)}const Gl=f({slice2d_:Ul});function Jl(s,e,t){const n=m(s,"x","slice3d");return d(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),C(n,e,t)}const Yl=f({slice3d_:Jl});function Xl(s,e,t){const n=m(s,"x","slice4d");return d(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),C(n,e,t)}const Ql=f({slice4d_:Xl});function Zl(s,e=-1){const t=m(s,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const n={logits:t},r={dim:e};return b.runKernel(Ta,n,r)}const Ml=f({softmax_:Zl});function ep(s){d(s.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${s.dtype}.`);const e={input:s};return b.runKernel(Sa,e)}const is=f({fft_:ep});function tp(s){d(s.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${s.dtype}.`);const e={input:s};return b.runKernel($a,e)}const lt=f({ifft_:tp});function sp(s){const e=s.shape[s.shape.length-1],t=s.size/e;let n;if(e<=2){const r=T(s,[t,e]);n=lt(r)}else{const r=[t,2*(e-1)],a=T(Qe(s),[t,e]),o=T($t(s),[t,e]),i=ve(C(a,[0,1],[t,e-2]),1),c=v(ve(C(o,[0,1],[t,e-2]),1),A(-1)),l=U([a,i],1),p=U([o,c],1),h=T(Ve(l,p),[r[0],r[1]]);n=lt(h)}if(n=Qe(n),s.rank===3&&s.shape[0]!==0){const r=n,a=s.shape[0];n=T(n,[a,n.shape[0]/a,n.shape[1]]),r.dispose()}return n}const mn=f({irfft_:sp});function np(s,e,t=0){const r={x:m(s,"x","split")},a={numOrSizeSplits:e,axis:t};return b.runKernel(_a,r,a)}const Ze=f({split_:np});function rp(s,e){d(s.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${s.dtype}`);let t=s.shape[s.shape.length-1];const n=s.size/t;let r;if(e!=null&&e<t){const w=s.shape.map(N=>0),S=s.shape.map(N=>N);S[s.shape.length-1]=e,r=C(s,w,S),t=e}else if(e!=null&&e>t){const w=s.shape.map(S=>S);w[s.shape.length-1]=e-t,r=U([s,gt(w)],s.shape.length-1),t=e}else r=s;const a=Kt(r),o=T(Ve(r,a),[n,t]),i=is(o),c=Math.floor(t/2)+1,l=Qe(i),p=$t(i),h=Ze(l,[c,t-c],l.shape.length-1),y=Ze(p,[c,t-c],p.shape.length-1),g=r.shape.slice();return g[r.shape.length-1]=c,T(Ve(h[0],y[0]),g)}const us=f({rfft_:rp});function ap(s,e){let t=m(s,"a","squaredDifference"),n=m(e,"b","squaredDifference");[t,n]=G(t,n),q(t.shape,n.shape);const r={a:t,b:n},a={};return b.runKernel(ka,r,a)}const hn=f({squaredDifference_:ap});function op(s,e){const t=m(s,"x","squeeze","string_or_numeric");return T(t,Ea(t.shape,e).newShape)}const cs=f({squeeze_:op});function ip(s,e=0){const t=rt(s,"tensors","stack","string_or_numeric");d(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&d(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const n=t,r={axis:e};return b.runKernel(va,n,r)}const de=f({stack_:ip});function up(s,e,t,n,r=0,a=0,o=0,i=0,c=0){const p={x:m(s,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:n,beginMask:r,endMask:a,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};return b.runKernel(Oa,p,h)}const cp=f({stridedSlice_:up});function lp(s){const t={x:m(s,"x","tan","float32")};return b.runKernel(Ia,t)}const pp=f({tan_:lp});function se(s,e){je(s);const t=We(s,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return qe(s,null,t,e)}function Je(s,e,t){if(je(s),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const n=We(s,t);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return qe(s,e,n,t)}function dn(s,e,t){if(je(s),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const n=We(s,t);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return qe(s,e,n,t)}function mp(s,e,t){if(je(s),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const n=We(s,t);if(n.length!==4&&n.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return qe(s,e,n,t)}function hp(s,e,t){if(je(s),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const n=We(s,t);if(n.length!==5&&n.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return qe(s,e,n,t)}function dp(s,e,t){if(je(s),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const n=We(s,t);if(n.length!==6&&n.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(n.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||n,qe(s,e,n,t)}function fp(s,e,t){const n=m(s,"tensor","tensorScatterupdate"),r=m(e,"indices","tensorScatterupdate","int32"),a=m(t,"updates","tensorScatterupdate");if(Fs(a,r,n.shape),n.dtype!==a.dtype)throw new Error(`tensor and updates must have the same dtype, instead they are ${n.dtype} and ${a.dtype}.`);const o={tensor:n,indices:r,updates:a},i={};return b.runKernel(Da,o,i)}const yp=f({tensorScatterUpdate_:fp});function gp(s,e=1,t=!0){const n=m(s,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=n.shape[n.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const a={x:n},o={k:e,sorted:t},[i,c]=b.runKernel(xa,a,o);return{values:i,indices:c}}const bp=f({topk_:gp});function Np(s,e=0,t=1,n,r){if(we(s),n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new as(e,t,n,!0,r),o=Be(s,n);for(let i=0;i<o.values.length;i++)o.values[i]=a.nextValue();return o.toTensor()}const wp=f({truncatedNormal_:Np});function Tp(s,e=0){const t=m(s,"x","unique","string_or_numeric");d(t.rank>0,()=>"The input tensor must be at least 1D");const n={x:t},r={axis:e},[a,o]=b.runKernel(Aa,n,r);return{values:a,indices:o}}const Sp=f({unique_:Tp});function $p(s,e,t){const n=m(s,"x","unsortedSegmentSum"),r=m(e,"segmentIds","unsortedSegmentSum","int32");d(Ps(t),()=>"numSegments must be of dtype int");const a={x:n,segmentIds:r},o={numSegments:t};return b.runKernel(Ca,a,o)}const _p=f({unsortedSegmentSum_:$p});function kp(s,e=0){const t=m(s,"x","unstack","string_or_numeric");d(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const n={value:t},r={axis:e};return b.runKernel(Pa,n,r)}const De=f({unstack_:kp});function Ep(s,e){return rs(s,e,"right")}function vp(s,e=!0,t,n){return b.makeVariable(s,e,t,n)}async function Op(s){const e=m(s,"condition","whereAsync","bool"),t=await e.data(),n=Fa(e.shape,t);return s!==e&&e.dispose(),n}const fn=Op;async function Ip(s,e,t){const n=m(s,"tensor","boolMask"),r=m(e,"mask","boolMask","bool"),a=t??0,o=r.rank,i=n.shape;d(o>0,()=>"mask cannot be scalar"),ae(i.slice(a,a+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let S=a;S<a+o;S++)c*=i[S];const l=i.slice(0,a).concat([c],i.slice(a+o)),p=T(n,l),h=T(r,[-1]),y=await fn(h),g=cs(y,[1]),w=Ms(p,g,a);return s!==n&&n.dispose(),e!==r&&r.dispose(),g.dispose(),p.dispose(),h.dispose(),y.dispose(),w}const Dp=Ip;function xp(s,e,t){const n=m(s,"x","transpose");if(e==null&&(e=n.shape.map((o,i)=>i).reverse()),d(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of perm ${e}.`),e.forEach(o=>{d(o>=0&&o<n.rank,()=>`All entries in 'perm' must be between 0 and ${n.rank-1} but got ${e}`)}),n.rank<=1)return n.clone();const r={x:n},a={perm:e};return n.dtype==="complex64"?ne(()=>{let o=Qe(n),i=$t(n);return o=b.runKernel(_t,{x:o},a),i=b.runKernel(_t,{x:i},a),t&&(i=ie(i)),Ve(o,i)}):b.runKernel(_t,r,a)}const xt=f({transpose_:xp});function Ap(s,e,t,n,r=!0){const a=m(s,"v","movingAverage"),o=m(e,"x","movingAverage"),i=m(t,"decay","movingAverage");La(a,o),d(ze(a.shape,o.shape),()=>"Shape mismatch in v and x");const c=A(1),l=I(c,i);let p=v(I(o,a),l);if(r){d(n!=null,()=>"When using zeroDebias: true, step is required.");const h=m(n,"step","movingAverage");p=H(p,I(c,Ut(i,h)))}return j(a,p)}const Cp=f({movingAverage_:Ap});function Pp(s,e,t){we(t);const n=m(s,"indices","scatterND","int32"),r=m(e,"updates","scatterND");Fs(r,n,t);const a={indices:n,updates:r},o={shape:t};return b.runKernel(za,a,o)}const Fp=f({scatterND_:Pp});function Lp(s,e,t,n){if(s.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${s.dtype}.`);if(s.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${s.shape}.`);const r=s.rank>0?s.shape[0]:1,a=s.rank>1?s.shape[1]:1;if(t.length!==a)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${a}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==n.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}function zp(s,e,t,n=0){we(t);const r=m(s,"sparseIndices","sparseToDense","int32"),a=m(e,"sparseValues","sparseToDense","string_or_numeric"),o=m(n,"defaultValue","sparseToDense",a.dtype);Lp(r,a,t,o);const i={sparseIndices:r,sparseValues:a,defaultValue:o},c={outputShape:t};return b.runKernel(Ra,i,c)}const Rp=f({sparseToDense_:zp});function Vp(s,e){const t=m(e,"indices","gatherND","int32"),r={params:m(s,"x","gatherND","string_or_numeric"),indices:t};return b.runKernel(Va,r)}const Bp=f({gatherND_:Vp});function jp(s,e){if(e==null)return s.shape.slice();if(ze(s.shape,e))return e;if(s.shape.length===e.length){const t=[];for(let n=0;n<s.shape.length;n++)e[n]==null&&s.shape[n]!=null?t.push(s.shape[n]):t.push(e[n]);return t}return e}function Wp(s,e,t,n){const r=m(s,"x","dropout");if(d(r.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${r.dtype} tensor instead.`),d(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return s instanceof _e?r.clone():r;const a=jp(r,t),o=1-e,i=H(Zs(j(os(a,0,1,"float32",n),o)),o);return v(r,i)}const qp=f({dropout_:Wp});function yn(s){return Math.floor(Math.pow(2,Math.ceil(Math.log(s)/Math.log(2))))}function ls(s,e,t){const n=1-s%2,r=new Float32Array(s);for(let a=0;a<s;++a){const o=2*Math.PI*a/(s+n-1);r[a]=e-t*Math.cos(o)}return se(r,"float32")}async function Kp(s,e,t=1){const n=m(s,"predictions","inTopK"),r=m(e,"targets","inTopK");d(n.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${n.rank}`),d(n.rank-1===r.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${n.rank} and targets rank ${r.rank}`),ae(n.shape.slice(0,n.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const a=n.shape[n.shape.length-1];d(t>0&&t<=a,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${a}), but got ${t}`);const o=await n.data(),i=await r.data(),[c,l]=[o.length/a,a],p=Ba("bool",c);for(let h=0;h<c;h++){const y=h*l,g=o.subarray(y,y+l),w=[];for(let S=0;S<g.length;S++)w.push({value:g[S],index:S});w.sort((S,N)=>N.value-S.value),p[h]=0;for(let S=0;S<t;S++)if(w[S].index===i[h]){p[h]=1;break}}return s!==n&&n.dispose(),e!==r&&r.dispose(),ke(p,r.shape,"bool")}const Hp=Kp;function Up(s,e,t,n,r,a="NHWC",o){let i=s;s.rank===3&&(i=T(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c=e;c.rank===3&&(c=T(e,[1,e.shape[0],e.shape[1],e.shape[2]])),d(i.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${i.shape}.`),d(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),d(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=a==="NHWC"?i.shape[3]:i.shape[1],p=a==="NHWC"?c.shape[3]:c.shape[1];d(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),d(p===t[3],()=>`Error in conv2dDerFilter: depth of dy (${p}) must match output depth for filter (${t[3]}).`),re("conv2dDerFilter",r,o);const h={x:i,dy:c},y={strides:n,pad:r,dataFormat:a,dimRoundingMode:o,filterShape:t};return b.runKernel(ja,h,y)}const Gp=f({conv2DBackpropFilter_:Up});function Jp({x:s,filter:e,strides:t,pad:n,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(c=c||"linear",Gt(b.state.gradientDepth,c)===!1){d(r==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${r} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let k=wt(s,e,t,n,r,a,o);return i!=null&&(k=j(k,i)),Jt(k,c,l,p)}const h=m(s,"x","conv2d","float32"),y=m(e,"filter","conv2d","float32");let g=h,w=!1;h.rank===3&&(w=!0,g=T(h,[1,h.shape[0],h.shape[1],h.shape[2]])),d(g.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${g.rank}.`),d(y.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${y.rank}.`),re("fused conv2d",n,o);const S=r==="NHWC"?g.shape[3]:g.shape[1];d(y.shape[2]===S,()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${y.shape[2]}.`),d(Ne(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const N=Ls(g.shape,y.shape,t,a,n,o);let $;i!=null&&($=m(i,"bias","fused conv2d"),[$]=G($,h),r==="NHWC"?q(N.outShape,$.shape):(d($.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${$.shape.length}.`),d($.shape.length===0||$.shape[0]===N.outChannels||$.shape[0]===1,()=>`Error in fused conv2d: bias shape (${$.shape}) is not compatible with the number of output channels (${N.outChannels})`)));let E;if(l!=null){const k=l.shape;if(d(k.length<=1||k.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${k.length}.`),k.length===1)d(k[0]===1||k[0]===N.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the number of output channels (${N.outChannels}).`);else if(k.length===3)try{q(k,N.outShape)}catch{const R=`Error in fused conv2d: PReLU activation weights (${k}) is not compatible with the output shape of the conv2d (${N.outShape}).`;throw Error(R)}E=m(l,"prelu weights","fused conv2d")}const O=(k,P)=>{d(r==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${r} but only NHWC is currently supported.`);const[R,F,z,V]=P,Z=Yt(k,z,c);d(zs(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const Q=Js(F.shape,Z,R,t,n),M=Gp(F,Z,R.shape,t,n),oe=[Q,M];if(V!=null){const xe=Xt(V,Z);oe.push(xe)}return oe},_={x:g,filter:y,bias:$,preluActivationWeights:E},D={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:p};return i==null?he((P,R,F)=>{let z=b.runKernel(ys,_,D);return F([R,P,z]),w&&(z=T(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:O}})(g,y):he((P,R,F,z)=>{let V=b.runKernel(ys,_,D);return z([R,P,V,F]),w&&(V=T(V,[V.shape[1],V.shape[2],V.shape[3]])),{value:V,gradFunc:O}})(g,y,$)}const Yp=f({fusedConv2d_:Jp});function Xp(s,e,t,n,r,a=[1,1],o){let i=s;s.rank===3&&(i=T(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let c=e;c.rank===3&&(c=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:i,dy:c},p={strides:n,pad:r,dimRoundingMode:o,dilations:a,filterShape:t};return b.runKernel(Wa,l,p)}const Qp=f({depthwiseConv2dNativeBackpropFilter_:Xp});function Zp(s,e,t,n,r,a=[1,1],o){let i=e,c=!1;e.rank===3&&(c=!0,i=T(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:i,filter:t},p={strides:n,pad:r,dimRoundingMode:o,dilations:a,inputShape:s},h=b.runKernel(qa,l,p);return c?T(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Mp=f({depthwiseConv2dNativeBackpropInput_:Zp});function em({x:s,filter:e,strides:t,pad:n,dataFormat:r="NHWC",dilations:a=[1,1],dimRoundingMode:o,bias:i,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:p}){if(Gt(b.state.gradientDepth,c)===!1){let D=ss(s,e,t,n,r,a,o);return i!=null&&(D=j(D,i)),Jt(D,c,l,p)}const h=m(s,"x","depthwiseConv2d","float32"),y=m(e,"filter","depthwiseConv2d","float32");let g=h,w=!1;h.rank===3&&(w=!0,g=T(h,[1,h.shape[0],h.shape[1],h.shape[2]])),d(g.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${g.rank}.`),d(y.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${y.rank}.`),d(g.shape[3]===y.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${g.shape[3]}) must match the inChannels dimension in filter ${y.shape[2]}.`),a==null&&(a=[1,1]),d(Ne(t,a),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),re("fused depthwiseConv2d",n,o);const S=Ls(g.shape,y.shape,t,a,n,o,!0);let N;i!=null&&(N=m(i,"bias","fused conv2d"),[N]=G(N,h),q(S.outShape,N.shape));let $;l!=null&&($=m(l,"prelu weights","fused depthwiseConv2d"));const E=(D,k)=>{d(zs(a),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${a}'`);const[P,R,F,z]=k,V=Yt(D,F,c),Z=Mp(R.shape,V,P,t,n,a,o),Q=Qp(R,V,P.shape,t,n,a,o);if(z!=null){const M=Xt(N,V);return[Z,Q,M]}return[Z,Q]},O={x:g,filter:y,bias:N,preluActivationWeights:$},_={strides:t,pad:n,dataFormat:r,dilations:a,dimRoundingMode:o,activation:c,leakyreluAlpha:p};return i==null?he((k,P,R)=>{let F=b.runKernel(gs,O,_);return R([P,k,F]),w&&(F=T(F,[F.shape[1],F.shape[2],F.shape[3]])),{value:F,gradFunc:E}})(g,y):he((k,P,R,F)=>{let z=b.runKernel(gs,O,_);return F([P,k,z,R]),w&&(z=T(z,[z.shape[1],z.shape[2],z.shape[3]])),{value:z,gradFunc:E}})(g,y,N)}const tm=f({fusedDepthwiseConv2d_:em});function sm({a:s,b:e,transposeA:t=!1,transposeB:n=!1,bias:r,activation:a="linear",preluActivationWeights:o,leakyreluAlpha:i=.2}){if(Gt(b.state.gradientDepth,a)===!1){let V=x(s,e,t,n);return r!=null&&(V=j(V,r)),Jt(V,a,o,i)}let c=m(s,"a","fused matMul"),l=m(e,"b","fused matMul");[c,l]=G(c,l);const p=t?c.shape[c.rank-2]:c.shape[c.rank-1],h=n?l.shape[l.rank-1]:l.shape[l.rank-2],y=t?c.shape[c.rank-1]:c.shape[c.rank-2],g=n?l.shape[l.rank-2]:l.shape[l.rank-1],w=c.shape.slice(0,-2),S=l.shape.slice(0,-2),N=be(w),$=be(S);d(p===h,()=>`Error in fused matMul: inner shapes (${p}) and (${h}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${n} must match.`);const O=q(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([y,g]),_=t?T(c,[N,p,y]):T(c,[N,y,p]),D=n?T(l,[$,g,h]):T(l,[$,h,g]);let k;r!=null&&(k=m(r,"bias","fused matMul"),[k]=G(k,c),q(O,k.shape));let P;o!=null&&(P=m(o,"prelu weights","fused matMul"));const R=(V,Z)=>{const[Q,M,oe,xe]=Z,ce=Yt(T(V,oe.shape),oe,a);let Ae,Ce;if(!t&&!n?(Ae=x(ce,M,!1,!0),Ce=x(Q,ce,!0,!1)):!t&&n?(Ae=x(ce,M,!1,!1),Ce=x(ce,Q,!0,!1)):t&&!n?(Ae=x(M,ce,!1,!0),Ce=x(Q,ce,!1,!1)):(Ae=x(M,ce,!0,!0),Ce=x(ce,Q,!0,!0)),r!=null){const Dn=Xt(xe,ce);return[Ae,Ce,Dn]}else return[Ae,Ce]},F={a:_,b:D,bias:k,preluActivationWeights:P},z={transposeA:t,transposeB:n,activation:a,leakyreluAlpha:i};return r==null?he((Z,Q,M)=>{const oe=b.runKernel(bs,F,z);return M([Z,Q,oe]),{value:T(oe,O),gradFunc:R}})(_,D):he((Z,Q,M,oe)=>{const xe=b.runKernel(bs,F,z);return oe([Z,Q,xe,M]),{value:T(xe,O),gradFunc:R}})(_,D,k)}const nm=f({fusedMatMul_:sm});const rm=Object.freeze(Object.defineProperty({__proto__:null,conv2d:Yp,depthwiseConv2d:tm,matMul:nm},Symbol.toStringTag,{value:"Module"}));function am(s){return ls(s,.54,.46)}const om=f({hammingWindow_:am});function im(s){return ls(s,.5,.5)}const gn=f({hannWindow_:im});function um(s,e,t,n=!1,r=0){let a=0;const o=[];for(;a+e<=s.size;)o.push(C(s,a,e)),a+=t;if(n)for(;a<s.size;){const i=a+e-s.size,c=U([C(s,a,e-i),dt([i],r)]);o.push(c),a+=t}return o.length===0?Je([],[0,e]):T(U(o),[o.length,e])}const bn=f({frame_:um});function cm(s,e,t,n,r=gn){n==null&&(n=yn(e));const a=bn(s,e,t),o=v(a,r(e));return us(o,n)}const lm=f({stft_:cm});function pm(s,e,t,n,r="bilinear",a=0){const o=m(s,"image","cropAndResize"),i=m(e,"boxes","cropAndResize","float32"),c=m(t,"boxInd","cropAndResize","int32"),l=i.shape[0];d(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),d(i.rank===2&&i.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${i.shape}.`),d(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${i.shape}.`),d(n.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${n.length}.`),d(n[0]>=1&&n[1]>=1,()=>`cropSize must be atleast [1,1], but was ${n}`),d(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const p={image:o,boxes:i,boxInd:c},h={method:r,extrapolationValue:a,cropSize:n};return b.runKernel(Ka,p,h)}const mm=f({cropAndResize_:pm});function hm(s){const e=m(s,"image","flipLeftRight","float32");d(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return b.runKernel(Ha,t,{})}const dm=f({flipLeftRight_:hm});function fm(s){const e=m(s,"image","grayscaleToRGB"),t=e.rank-1,n=e.shape[t];d(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),d(n===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${n}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Ge(e,r)}const ym=f({grayscaleToRGB_:fm});function gm(s){const e=m(s,"image","RGBToGrayscale"),t=e.rank-1,n=e.shape[t];d(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),d(n===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${n}.`);const r=e.dtype,a=B(e,"float32"),o=se([.2989,.587,.114]);let i;switch(e.rank){case 2:i=Pe("ij,j->i",a,o);break;case 3:i=Pe("ijk,k->ij",a,o);break;case 4:i=Pe("ijkl,l->ijk",a,o);break;case 5:i=Pe("ijklm,m->ijkl",a,o);break;case 6:i=Pe("ijklmn,n->ijklm",a,o);break;default:throw new Error("Not a valid tensor rank.")}return i=ye(i,-1),B(i,r)}const bm=f({rgbToGrayscale_:gm});function Nm(s,e,t=0,n=.5){const r=m(s,"image","rotateWithOffset","float32");d(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const a={image:r},o={radians:e,fillValue:t,center:n};return b.runKernel(Ua,a,o)}const wm=f({rotateWithOffset_:Nm});function Ke(s,e,t,n,r,a){n==null&&(n=.5),r==null&&(r=Number.NEGATIVE_INFINITY),a==null&&(a=0);const o=s.shape[0];return t=Math.min(t,o),d(0<=n&&n<=1,()=>`iouThreshold must be in [0, 1], but was '${n}'`),d(s.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${s.rank}'`),d(s.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${s.shape[1]}`),d(e.rank===1,()=>"scores must be a 1D tensor"),d(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),d(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:n,scoreThreshold:r,softNmsSigma:a}}function Tm(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY){const a=m(s,"boxes","nonMaxSuppression","float32"),o=m(e,"scores","nonMaxSuppression","float32"),i=Ke(a,o,t,n,r);t=i.maxOutputSize,n=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:t,iouThreshold:n,scoreThreshold:r};return b.runKernel(Ga,{boxes:a,scores:o},c)}const Sm=f({nonMaxSuppression_:Tm});async function $m(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY){const a=m(s,"boxes","nonMaxSuppressionAsync"),o=m(e,"scores","nonMaxSuppressionAsync"),i=Ke(a,o,t,n,r);t=i.maxOutputSize,n=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([a.data(),o.data()]),l=c[0],p=c[1],{selectedIndices:h}=Ja(l,p,t,n,r);return a!==s&&a.dispose(),o!==e&&o.dispose(),se(h,"int32")}const _m=$m;function km(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=m(s,"boxes","nonMaxSuppression"),i=m(e,"scores","nonMaxSuppression"),c=Ke(o,i,t,n,r,a);t=c.maxOutputSize,n=c.iouThreshold,r=c.scoreThreshold,a=c.softNmsSigma;const l={boxes:o,scores:i},p={maxOutputSize:t,iouThreshold:n,scoreThreshold:r,softNmsSigma:a},h=b.runKernel(Ya,l,p);return{selectedIndices:h[0],selectedScores:h[1]}}const Em=f({nonMaxSuppressionWithScore_:km});async function vm(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=0){const o=m(s,"boxes","nonMaxSuppressionAsync"),i=m(e,"scores","nonMaxSuppressionAsync"),c=Ke(o,i,t,n,r,a);t=c.maxOutputSize,n=c.iouThreshold,r=c.scoreThreshold,a=c.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),p=l[0],h=l[1],{selectedIndices:y,selectedScores:g}=Xa(p,h,t,n,r,a);return o!==s&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:se(y,"int32"),selectedScores:se(g)}}const Om=vm;function Im(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=m(s,"boxes","nonMaxSuppression"),i=m(e,"scores","nonMaxSuppression"),c=Ke(o,i,t,n,r,null),l=c.maxOutputSize,p=c.iouThreshold,h=c.scoreThreshold,y={boxes:o,scores:i},g={maxOutputSize:l,iouThreshold:p,scoreThreshold:h,padToMaxOutputSize:a},w=b.runKernel(Qa,y,g);return{selectedIndices:w[0],validOutputs:w[1]}}const Dm=f({nonMaxSuppressionPadded_:Im});async function xm(s,e,t,n=.5,r=Number.NEGATIVE_INFINITY,a=!1){const o=m(s,"boxes","nonMaxSuppressionAsync"),i=m(e,"scores","nonMaxSuppressionAsync"),c=Ke(o,i,t,n,r,null),l=c.maxOutputSize,p=c.iouThreshold,h=c.scoreThreshold,[y,g]=await Promise.all([o.data(),i.data()]),{selectedIndices:w,validOutputs:S}=Za(y,g,l,p,h,a);return o!==s&&o.dispose(),i!==e&&i.dispose(),{selectedIndices:se(w,"int32"),validOutputs:A(S,"int32")}}const Am=xm;function Cm(s,e,t=!1,n=!1){const r=m(s,"images","resizeBilinear");d(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),d(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),d(n===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=T(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},c={alignCorners:t,halfPixelCenters:n,size:e},l=b.runKernel(Ma,i,c);return o?T(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Pm=f({resizeBilinear_:Cm});function Fm(s,e,t=!1,n=!1){const r=m(s,"images","resizeNearestNeighbor");d(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),d(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),d(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),d(n===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=r,o=!1;r.rank===3&&(o=!0,a=T(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const i={images:a},c={alignCorners:t,halfPixelCenters:n,size:e},l=b.runKernel(eo,i,c);return o?T(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const Lm=f({resizeNearestNeighbor_:Fm});function zm(s,e="binary",t=!1,n=.5){const r=m(s,"image","threshold"),a=.2989,o=.587,i=.114,c=r.shape[0]*r.shape[1];let l=v(se([n]),255),p,h,y,g;if(d(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),d(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),d(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),d(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[p,h,y]=Ze(r,[1,1,1],-1);const N=v(p,a),$=v(h,o),E=v(y,i);g=j(j(N,$),E)}else g=s;if(e==="otsu"){const N=Gs(B(pn(g),"int32"),ke([]),256);l=Rm(N,c)}const w=t?ns(g,l):St(g,l);return B(v(w,255),"int32")}function Rm(s,e){let t=se([-1]),n=se([0]),r=se([0]),a,o,i,c,l,p;for(let h=0;h<s.size-1;h++){a=C(s,0,h+1),o=C(s,h+1),l=H(L(a),e),p=H(L(o),e);const y=L(v(a,Xe(0,a.size)));i=H(y,L(a));const g=dt(o.shape,a.size),w=j(Xe(0,o.size),g),S=v(o,w);c=H(L(S),L(o));const N=I(i,c),$=I(i,c),E=v(l,p);r=v(v(E,N),$);const O=St(r,n);n=ge(O,r,n),t=ge(O,se([h]),t)}return t}const Vm=f({threshold_:zm});function Bm(s,e,t="nearest",n="constant",r=0,a){const o=m(s,"image","transform","float32"),i=m(e,"transforms","transform","float32");d(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),d(i.rank===2&&(i.shape[0]===o.shape[0]||i.shape[0]===1)&&i.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),d(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const c={image:o,transforms:i},l={interpolation:t,fillMode:n,fillValue:r,outputShape:a};return b.runKernel(to,c,l)}const jm=f({transform_:Bm});function Wm(s,e,t){const n=m(s,"a","bandPart");d(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);const r=n.shape,[a,o]=n.shape.slice(-2);let i,c;typeof e=="number"?(d(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),d(e<=a,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`),i=m(e<0?a:e,"numLower","bandPart")):(d(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),i=ge(Dt(e,0),a,ct(e,a))),typeof t=="number"?(d(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),d(t<=o,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`),c=m(t<0?o:t,"numUpper","bandPart")):(d(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=ge(Dt(t,0),o,ct(t,o)));const l=T(Xe(0,a,1,"int32"),[-1,1]),p=Xe(0,o,1,"int32"),h=I(l,p),y=it(ns(h,i),en(h,ie(c))),g=gt([a,o],n.dtype);return T(de(De(T(n,[-1,a,o])).map(w=>ge(y,w,g))),r)}const qm=f({bandPart_:Wm});function Km(s){let e;if(Array.isArray(s)){e=!1,d(s!=null&&s.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=s[0].shape[0];for(let a=1;a<s.length;++a)d(s[a].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${s[a].shape[0]} vs. ${r})`)}else e=!0,s=Ze(s,s.shape[0],0).map(r=>cs(r,[0]));d(s.length<=s[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${s.length}) exceeds number of dimensions (${s[0].shape[0]}).`);const t=[],n=s;for(let r=0;r<s.length;++r)t.push(b.tidy(()=>{let a=n[r];if(r>0)for(let o=0;o<r;++o){const i=v(L(v(t[o],a)),t[o]);a=I(a,i)}return H(a,Tt(a,"euclidean"))}));return e?de(t,0):t}const Hm=f({gramSchmidt_:Km});function Um(s,e=!1){if(d(s.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${s.rank}`),s.rank===2)return Ts(s,e);{const t=s.shape.slice(0,s.shape.length-2).reduce((c,l)=>c*l),n=De(T(s,[t,s.shape[s.shape.length-2],s.shape[s.shape.length-1]]),0),r=[],a=[];n.forEach(c=>{const[l,p]=Ts(c,e);r.push(l),a.push(p)});const o=T(de(r,0),s.shape),i=T(de(a,0),s.shape);return[o,i]}}function Ts(s,e=!1){return b.tidy(()=>{d(s.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${s.shape.length}D Tensor.`);const t=s.shape[0],n=s.shape[1];let r=Qs(t),a=Fe(s);const o=Je([[1]],[1,1]);let i=Fe(o);const c=t>=n?n:t;for(let l=0;l<c;++l){const p=a,h=i,y=r;[i,a,r]=b.tidy(()=>{const g=C(a,[l,l],[t-l,1]),w=Tt(g),S=C(a,[l,l],[1,1]),N=ge(St(S,0),Je([[-1]]),Je([[1]])),$=I(S,v(N,w)),E=H(g,$);E.shape[0]===1?i=Fe(o):i=U([o,C(E,[1,0],[E.shape[0]-1,E.shape[1]])],0);const O=ie(H(x(N,$),w)),_=C(a,[l,0],[t-l,n]),D=v(O,i),k=xt(i);if(l===0)a=I(_,x(D,x(k,_)));else{const F=I(_,x(D,x(k,_)));a=U([C(a,[0,0],[l,n]),F],0)}const P=xt(D),R=C(r,[0,l],[t,r.shape[1]-l]);if(l===0)r=I(R,x(x(R,i),P));else{const F=I(R,x(x(R,i),P));r=U([C(r,[0,0],[t,l]),F],1)}return[i,a,r]}),Rs([p,h,y])}return!e&&t>n&&(r=C(r,[0,0],[t,n]),a=C(a,[0,0],[n,n])),[r,a]})}const Gm=f({qr_:Um});var J;(function(s){s[s.NONE=0]="NONE",s[s.MEAN=1]="MEAN",s[s.SUM=2]="SUM",s[s.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(J||(J={}));function Jm(s,e,t=J.SUM_BY_NONZERO_WEIGHTS){const n=m(s,"losses","computeWeightedLoss");let r=null;e!=null&&(r=m(e,"weights","computeWeightedLoss"));const a=r==null?n:v(n,r);if(t===J.NONE)return a;if(t===J.SUM)return L(a);if(t===J.MEAN){if(r==null)return ut(a);{const o=n.size/r.size,i=H(L(a),L(r));return o>1?H(i,A(o)):i}}if(t===J.SUM_BY_NONZERO_WEIGHTS){if(r==null)return H(L(a),A(n.size));{const o=v(r,$e(n.shape)),i=B(L(un(o,A(0))),"float32");return H(L(a),i)}}throw Error(`Unknown reduction: ${t}`)}const fe=f({computeWeightedLoss_:Jm});function Ym(s,e,t,n=J.SUM_BY_NONZERO_WEIGHTS){const r=m(s,"labels","absoluteDifference"),a=m(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=m(t,"weights","absoluteDifference")),ae(r.shape,a.shape,"Error in absoluteDifference: ");const i=ee(I(r,a));return fe(i,o,n)}const Xm=f({absoluteDifference_:Ym});function Qm(s,e,t,n,r=J.SUM_BY_NONZERO_WEIGHTS){const a=m(s,"labels","cosineDistance"),o=m(e,"predictions","cosineDistance");let i=null;n!=null&&(i=m(n,"weights","cosineDistance")),ae(a.shape,o.shape,"Error in cosineDistance: ");const c=A(1),l=I(c,L(v(a,o),t,!0));return fe(l,i,r)}const Zm=f({cosineDistance_:Qm});function Mm(s,e,t,n=J.SUM_BY_NONZERO_WEIGHTS){let r=m(s,"labels","hingeLoss");const a=m(e,"predictions","hingeLoss");let o=null;t!=null&&(o=m(t,"weights","hingeLoss")),ae(r.shape,a.shape,"Error in hingeLoss: ");const i=A(1);r=I(v(A(2),r),i);const c=Qt(I(i,v(r,a)));return fe(c,o,n)}const eh=f({hingeLoss_:Mm});function th(s,e,t,n=1,r=J.SUM_BY_NONZERO_WEIGHTS){const a=m(s,"labels","huberLoss"),o=m(e,"predictions","huberLoss");let i=null;t!=null&&(i=m(t,"weights","huberLoss")),ae(a.shape,o.shape,"Error in huberLoss: ");const c=A(n),l=ee(I(o,a)),p=ct(l,c),h=I(l,p),y=j(v(A(.5),yt(p)),v(c,h));return fe(y,i,r)}const sh=f({huberLoss_:th});function nh(s,e,t,n=1e-7,r=J.SUM_BY_NONZERO_WEIGHTS){const a=m(s,"labels","logLoss"),o=m(e,"predictions","logLoss");let i=null;t!=null&&(i=m(t,"weights","logLoss")),ae(a.shape,o.shape,"Error in logLoss: ");const c=A(1),l=A(n),p=ie(v(a,Ye(j(o,l)))),h=v(I(c,a),Ye(j(I(c,o),l))),y=I(p,h);return fe(y,i,r)}const rh=f({logLoss_:nh});function ah(s,e,t,n=J.SUM_BY_NONZERO_WEIGHTS){const r=m(s,"labels","meanSquaredError"),a=m(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=m(t,"weights","meanSquaredError")),ae(r.shape,a.shape,"Error in meanSquaredError: ");const i=hn(r,a);return fe(i,o,n)}const oh=f({meanSquaredError_:ah});function ih(s,e){const t=m(s,"labels","sigmoidCrossEntropyWithLogits"),n=m(e,"logits","sigmoidCrossEntropyWithLogits");ae(t.shape,n.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=Qt(n),a=v(n,t),o=tn(Ee(ie(ee(n))));return j(I(r,a),o)}function uh(s,e,t,n=0,r=J.SUM_BY_NONZERO_WEIGHTS){let a=m(s,"multiClassLabels","sigmoidCrossEntropy");const o=m(e,"logits","sigmoidCrossEntropy");let i=null;if(t!=null&&(i=m(t,"weights","sigmoidCrossEntropy")),ae(a.shape,o.shape,"Error in sigmoidCrossEntropy: "),n>0){const l=A(n),p=A(1),h=A(.5);a=j(v(a,I(p,l)),v(h,l))}const c=ih(a,o);return fe(c,i,r)}const ch=f({sigmoidCrossEntropy_:uh});function lh(s,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return he((r,a,o)=>{const c=nn(a,[t],!0),l=I(B(a,"float32"),c);o([r,l]);const p=ie(v(l,r));return{value:L(p,[t]),gradFunc:(g,w)=>{const[S,N]=w,$=ft(g.shape,[t]);return[v(T(g,$),I(B(S,"float32"),Ee(N))),v(T(g,$),I(Ee(N),B(S,"float32")))]}}})(s,e)}function ph(s,e,t,n=0,r=J.SUM_BY_NONZERO_WEIGHTS){let a=m(s,"onehotLabels","softmaxCrossEntropy");const o=m(e,"logits","softmaxCrossEntropy");let i=null;if(t!=null&&(i=m(t,"weights","softmaxCrossEntropy")),ae(a.shape,o.shape,"Error in softmaxCrossEntropy: "),n>0){const l=A(n),p=A(1),h=A(a.shape[1]);a=j(v(a,I(p,l)),H(l,h))}const c=lh(a,o);return fe(c,i,r)}const mh=f({softmaxCrossEntropy_:ph});function hh(s,e,t,n){const r=m(s,"indices","sparseFillEmptyRows","int32"),a=m(e,"values","sparseFillEmptyRows"),o=m(t,"denseShape","sparseFillEmptyRows","int32"),i=m(n,"defaultValue","sparseFillEmptyRows",a.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(a.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${a.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(i.rank!==0)throw new Error(`Default value should be a scalar but received shape ${i.shape}`);const c={indices:r,values:a,denseShape:o,defaultValue:i},l=b.runKernel(so,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}const dh=f({sparseFillEmptyRows_:hh});function fh(s,e,t){const n=m(s,"inputIndices","sparseReshape","int32"),r=m(e,"inputShape","sparseReshape","int32"),a=m(t,"newShape","sparseReshape","int32");if(n.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${n.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${a.shape}`);const o={inputIndices:n,inputShape:r,newShape:a},i=b.runKernel(no,o);return{outputIndices:i[0],outputShape:i[1]}}const yh=f({sparseReshape_:fh});function gh(s,e,t){const n=m(s,"data","sparseSegmentMean"),r=m(e,"indices","sparseSegmentMean","int32"),a=m(t,"segmentIds","sparseSegmentMean","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${a.shape}`);const o={data:n,indices:r,segmentIds:a};return b.runKernel(ro,o)}const bh=f({sparseSegmentMean_:gh});function Nh(s,e,t){const n=m(s,"data","sparseSegmentSum"),r=m(e,"indices","sparseSegmentSum","int32"),a=m(t,"segmentIds","sparseSegmentSum","int32");if(n.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(a.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${a.shape}`);const o={data:n,indices:r,segmentIds:a};return b.runKernel(ao,o)}const wh=f({sparseSegmentSum_:Nh});function Th(s,e,t,n,r,a,o,i){const c=m(s,"data","stringNGrams","string");if(c.dtype!=="string")throw new Error("Data must be of datatype string");if(c.shape.length!==1)throw new Error(`Data must be a vector, saw: ${c.shape}`);const l=m(e,"dataSplits","stringNGrams");if(l.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const p={separator:t,nGramWidths:n,leftPad:r,rightPad:a,padWidth:o,preserveShortSequences:i},h={data:c,dataSplits:l},y=b.runKernel(oo,h,p);return{nGrams:y[0],nGramsSplits:y[1]}}const Sh=f({stringNGrams_:Th});function $h(s,e,t=!0){const n=m(s,"input","stringSplit","string"),r=m(e,"delimiter","stringSplit","string");if(n.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${n.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const a={skipEmpty:t},o={input:n,delimiter:r},i=b.runKernel(io,o,a);return{indices:i[0],values:i[1],shape:i[2]}}const _h=f({stringSplit_:$h});function kh(s,e){const t=m(s,"input","stringToHashBucketFast","string"),n={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return b.runKernel(uo,r,n)}const Eh=f({stringToHashBucketFast_:kh});function vh(s,e,t,n=!0){const r=m(s,"input","staticRegexReplace","string"),a={pattern:e,rewrite:t,replaceGlobal:n};return b.runKernel(co,{x:r},a)}const Oh=f({staticRegexReplace_:vh});const Ih={fft:is,ifft:lt,rfft:us,irfft:mn},Dh={hammingWindow:om,hannWindow:gn,frame:bn,stft:lm},xh={flipLeftRight:dm,grayscaleToRGB:ym,resizeNearestNeighbor:Lm,resizeBilinear:Pm,rgbToGrayscale:bm,rotateWithOffset:wm,cropAndResize:mm,nonMaxSuppression:Sm,nonMaxSuppressionAsync:_m,nonMaxSuppressionWithScore:Em,nonMaxSuppressionWithScoreAsync:Om,nonMaxSuppressionPadded:Dm,nonMaxSuppressionPaddedAsync:Am,threshold:Vm,transform:jm},Ah={bandPart:qm,gramSchmidt:Hm,qr:Gm},Ch={absoluteDifference:Xm,computeWeightedLoss:fe,cosineDistance:Zm,hingeLoss:eh,huberLoss:sh,logLoss:rh,meanSquaredError:oh,sigmoidCrossEntropy:ch,softmaxCrossEntropy:mh},Ph={sparseFillEmptyRows:dh,sparseReshape:yh,sparseSegmentMean:bh,sparseSegmentSum:wh},Fh={stringNGrams:Sh,stringSplit:_h,stringToHashBucketFast:Eh,staticRegexReplace:Oh};const Lh="model",zh=".json",Rh=".weights.bin";function Ss(s){return new Promise(e=>setTimeout(e)).then(s)}class Oe{constructor(e){if(!ue().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Oe.URL_SCHEME)&&(e=e.slice(Oe.URL_SCHEME.length)),(e==null||e.length===0)&&(e=Lh),this.modelJsonFileName=e+zh,this.weightDataFileName=e+Rh}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=bt.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],a=Vs(e,r),o=window.URL.createObjectURL(new Blob([JSON.stringify(a)],{type:"application/json"})),i=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(i.download=this.modelJsonFileName,i.href=o,await Ss(()=>i.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const c=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;c.download=this.weightDataFileName,c.href=n,await Ss(()=>c.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:es(e)}}}}Oe.URL_SCHEME="downloads://";class Vh{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const n=new FileReader;n.onload=r=>{const a=JSON.parse(r.target.result),o=a.modelTopology;if(o==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(a.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const c=Zt(a,l=>this.loadWeights(l));e(c)},n.onerror=r=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),n.readAsText(this.jsonFile)})}loadWeights(e){const t=[],n=[];for(const o of e)t.push(...o.weights),n.push(...o.paths);const r=this.checkManifestAndWeightFiles(e),a=n.map(o=>this.loadWeightsFile(o,r[o]));return Promise.all(a).then(o=>[t,o])}loadWeightsFile(e,t){return new Promise((n,r)=>{const a=new FileReader;a.onload=o=>{const i=o.target.result;n(i)},a.onerror=o=>r(`Failed to weights data from file of path '${e}'.`),a.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map(a=>Ns(a.name)),r={};for(const a of e)a.paths.forEach(o=>{const i=Ns(o);if(t.indexOf(i)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${i}'`);if(t.push(i),n.indexOf(i)===-1)throw new Error(`Weight file with basename '${i}' is not provided.`);r[o]=this.weightsFiles[n.indexOf(i)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return r}}const Bh=s=>ue().getBool("IS_BROWSER")&&!Array.isArray(s)&&s.startsWith(Oe.URL_SCHEME)?jh(s.slice(Oe.URL_SCHEME.length)):null;Mt.registerSaveRouter(Bh);function jh(s="model"){return new Oe(s)}function Wh(s){return new Vh(s)}function $s(s,e,t,n){o(s),t=t??0,n=n??1,i(t,n);let r=0;const a=c=>(c.then(l=>{const p=t+ ++r/s.length*(n-t);return e(p),l}),c);function o(c){d(c!=null&&Array.isArray(c)&&c.length>0,()=>"promises must be a none empty array")}function i(c,l){d(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${c}`),d(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${l}`),d(l>=c,()=>`startFraction must be no more than endFraction, but got startFraction ${c} and endFraction ${l}`)}return Promise.all(s.map(a))}async function Nn(s,e){e==null&&(e={});const t=e.fetchFunc==null?ue().platform.fetch:e.fetchFunc,n=s.map(h=>t(h,e.requestInit,{isBinary:!0})),i=(e.onProgress==null?await Promise.all(n):await $s(n,e.onProgress,0,.5)).map(h=>h.arrayBuffer());return e.onProgress==null?await Promise.all(i):await $s(i,e.onProgress,.5,1)}function qh(s,e){var t;const n=e.fetchFunc==null?ue().platform.fetch:e.fetchFunc;let r=0,a;return(t=e.onProgress)===null||t===void 0||t.call(e,0),new ReadableStream({pull:async o=>{for(var i;r<s.length;){a||(a=(await n(s[r],e.requestInit,{isBinary:!0})).body.getReader());const{done:c,value:l}=await a.read();if(c){r++,a=void 0,(i=e.onProgress)===null||i===void 0||i.call(e,r/s.length);continue}o.enqueue(l);return}o.close()}})}async function Kh(s,e="",t,n){return wn(o=>Nn(o,{requestInit:n}))(s,e,t)}function wn(s){return async(e,t="",n)=>{const r=e.map(()=>!1),a={},o=n!=null?n.map(()=>!1):[],i=[];if(e.forEach((g,w)=>{let S=0;g.weights.forEach(N=>{const $="quantization"in N?N.quantization.dtype:N.dtype,E=lo[$]*be(N.shape),O=()=>{r[w]=!0,a[w]==null&&(a[w]=[]),a[w].push({manifestEntry:N,groupOffset:S,sizeBytes:E})};n!=null?n.forEach((_,D)=>{_===N.name&&(O(),o[D]=!0)}):O(),i.push(N.name),S+=E})}),!o.every(g=>g)){const g=n.filter((w,S)=>!o[S]);throw new Error(`Could not find weights in manifest with names: ${g.join(", ")}. 
Manifest JSON has weights with names: ${i.join(", ")}.`)}const c=r.reduce((g,w,S)=>(w&&g.push(S),g),[]),l=[];c.forEach(g=>{e[g].paths.forEach(w=>{const S=t+(t.endsWith("/")?"":"/")+w;l.push(S)})});const p=await s(l),h={};let y=0;return c.forEach(g=>{const w=e[g].paths.length,S=new bt(p.slice(y,y+w));a[g].forEach($=>{const E=S.slice($.groupOffset,$.groupOffset+$.sizeBytes),O=Bs(E,[$.manifestEntry]);for(const _ in O)h[_]=O[_]}),y+=w}),h}}const Hh="application/octet-stream",Uh="application/json";class ps{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(d(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ue().platform.fetch,d(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&d(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=Vs(e,n);if(t.body.append("model.json",new Blob([JSON.stringify(r)],{type:Uh}),"model.json"),e.weightData!=null){const o=bt.join(e.weightData);t.body.append("model.weights.bin",new Blob([o],{type:Hh}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:es(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const n=t.modelTopology,r=t.weightsManifest;if(n==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();const e=await this.loadModelJSON();return Zt(e,t=>this.loadWeights(t))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=at(e.weightsManifest),r=()=>qh(t,this.loadOptions);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:r})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,r]=Gh(t),a=this.weightPathPrefix||n,o=[],i=[];for(const c of e)for(const l of c.paths)this.weightUrlConverter!=null?i.push(this.weightUrlConverter(l)):o.push(a+l+r);return this.weightUrlConverter&&o.push(...await Promise.all(i)),o}async loadWeights(e){const t=await this.getWeightUrls(e),n=at(e),r=await Nn(t,this.loadOptions);return[n,r]}}ps.URL_SCHEME_REGEX=/^https?:\/\//;function Gh(s){const e=s.lastIndexOf("/"),t=s.lastIndexOf("?"),n=s.substring(0,e),r=t>e?s.substring(t):"";return[n+"/",r]}function At(s){return s.match(ps.URL_SCHEME_REGEX)!=null}const Tn=(s,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(s)?t=s.every(n=>At(n)):t=At(s),t)return ms(s,e)}return null};Mt.registerSaveRouter(Tn);Mt.registerLoadRouter(Tn);function ms(s,e){return new ps(s,e)}function Jh(s,e){return ms(s,e)}class kt{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class Sn{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Yh{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Xh(s,e,t,n){const r=arguments;return new Yh(pt(...r))}function pt(s,e,t,n){return arguments.length===1?s.modelTopology!=null||s.weightSpecs!=null?new kt(s):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kt({modelTopology:s})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kt({modelTopology:s,weightSpecs:e,weightData:t,trainingConfig:n}))}function Qh(s){return new Sn(s)}function Zh(s){return new Sn(s)}const $n=Object.freeze(Object.defineProperty({__proto__:null,CompositeArrayBuffer:bt,browserFiles:Wh,browserHTTPRequest:Jh,concatenateArrayBuffers:po,copyModel:mo,decodeWeights:Bs,decodeWeightsStream:js,encodeWeights:ho,fromMemory:Xh,fromMemorySync:pt,getLoadHandlers:fo,getModelArtifactsForJSON:Zt,getModelArtifactsForJSONSync:Ws,getModelArtifactsInfoForJSON:es,getSaveHandlers:yo,getWeightSpecs:at,http:ms,isHTTPScheme:At,listModels:go,loadWeights:Kh,moveModel:bo,registerLoadRouter:No,registerSaveRouter:wo,removeModel:To,weightsLoaderFactory:wn,withSaveHandler:Qh,withSaveHandlerSync:Zh},Symbol.toStringTag,{value:"Module"}));let Te,_s=!1;function _n(s,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(s==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,n=!1,r=!1,a=!1,o=!1,i=!1;if(s.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&s instanceof ImageData)n=!0;else if(typeof HTMLVideoElement<"u"&&s instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement<"u"&&s instanceof HTMLImageElement)a=!0;else if(s.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&s instanceof ImageBitmap)i=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${s.constructor.name}`);if(qs(ws,b.backendName)!=null){const w={pixels:s},S={numChannels:e};return b.runKernel(ws,w,S)}const[l,p]=r?[s.videoWidth,s.videoHeight]:[s.width,s.height];let h;if(o)h=s.getContext("2d").getImageData(0,0,l,p).data;else if(n||t)h=s.data;else if(a||r||i){if(Te==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")Te=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Te=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});Te.canvas.width=l,Te.canvas.height=p,Te.drawImage(s,0,0,l,p),h=Te.getImageData(0,0,l,p).data}let y;if(e===4)y=new Int32Array(h);else{const w=l*p;y=new Int32Array(w*e);for(let S=0;S<w;S++)for(let N=0;N<e;++N)y[S*e+N]=h[S*4+N]}return dn(y,[p,l,e],"int32")}function Mh(s){return s!=null&&s.data instanceof Uint8Array}function ed(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function td(s){return s!=null&&s.width!==0&&s.height!==0}function sd(s){return ed()&&!(s instanceof ImageBitmap)&&td(s)&&!Mh(s)}async function nd(s,e=3){let t=null;if(ue().getBool("WRAP_TO_IMAGEBITMAP")&&sd(s)){let n;try{n=await createImageBitmap(s,{premultiplyAlpha:"none"})}catch{n=null}n!=null&&n.width===s.width&&n.height===s.height?t=n:t=s}else t=s;return _n(t,e)}function kn(s){if(s.rank!==2&&s.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${s.rank}.`);const e=s.rank===2?1:s.shape[2];if(e>4||e===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${e}`);if(s.dtype!=="float32"&&s.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${s.dtype}. Please use float32 or int32 tensors.`)}function rd(s){const e=s?.alpha||1;if(e>1||e<0)throw new Error(`Alpha value ${e} is suppoed to be in range [0 - 1].`)}async function ad(s,e){let t=m(s,"img","toPixels");if(!(s instanceof _e)){const l=t;t=B(l,"int32"),l.dispose()}kn(t);const[n,r]=t.shape.slice(0,2),a=t.rank===2?1:t.shape[2],o=await t.data(),i=t.dtype==="float32"?255:1,c=new Uint8ClampedArray(r*n*4);for(let l=0;l<n*r;++l){const p=[0,0,0,255];for(let y=0;y<a;y++){const g=o[l*a+y];if(t.dtype==="float32"){if(g<0||g>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${g}.`)}else if(t.dtype==="int32"&&(g<0||g>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${g}.`);a===1?(p[0]=g*i,p[1]=g*i,p[2]=g*i):p[y]=g*i}const h=l*4;c[h+0]=Math.round(p[0]),c[h+1]=Math.round(p[1]),c[h+2]=Math.round(p[2]),c[h+3]=Math.round(p[3])}if(e!=null){_s||qs(Ks,b.backendName)!=null&&(console.warn("tf.browser.toPixels is not efficient to draw tensor on canvas. Please try tf.browser.draw instead."),_s=!0),e.width=r,e.height=n;const l=e.getContext("2d"),p=new ImageData(c,r,n);l.putImageData(p,0,0)}return t!==s&&t.dispose(),c}function od(s,e,t){let n=m(s,"img","draw");if(!(s instanceof _e)){const o=n;n=B(o,"int32"),o.dispose()}kn(n),rd(t?.imageOptions);const r={image:n},a={canvas:e,options:t};b.runKernel(Ks,r,a)}const id=f({fromPixels_:_n}),zf=Object.freeze(Object.defineProperty({__proto__:null,draw:od,fromPixels:id,fromPixelsAsync:nd,toPixels:ad},Symbol.toStringTag,{value:"Module"}));const ud=ue();ud.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,s=>{s&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});var Y;(function(s){s[s.DT_INVALID=0]="DT_INVALID",s[s.DT_FLOAT=1]="DT_FLOAT",s[s.DT_DOUBLE=2]="DT_DOUBLE",s[s.DT_INT32=3]="DT_INT32",s[s.DT_UINT8=4]="DT_UINT8",s[s.DT_INT16=5]="DT_INT16",s[s.DT_INT8=6]="DT_INT8",s[s.DT_STRING=7]="DT_STRING",s[s.DT_COMPLEX64=8]="DT_COMPLEX64",s[s.DT_INT64=9]="DT_INT64",s[s.DT_BOOL=10]="DT_BOOL",s[s.DT_QINT8=11]="DT_QINT8",s[s.DT_QUINT8=12]="DT_QUINT8",s[s.DT_QINT32=13]="DT_QINT32",s[s.DT_BFLOAT16=14]="DT_BFLOAT16",s[s.DT_QINT16=15]="DT_QINT16",s[s.DT_QUINT16=16]="DT_QUINT16",s[s.DT_UINT16=17]="DT_UINT16",s[s.DT_COMPLEX128=18]="DT_COMPLEX128",s[s.DT_HALF=19]="DT_HALF",s[s.DT_RESOURCE=20]="DT_RESOURCE",s[s.DT_VARIANT=21]="DT_VARIANT",s[s.DT_UINT32=22]="DT_UINT32",s[s.DT_UINT64=23]="DT_UINT64",s[s.DT_FLOAT_REF=101]="DT_FLOAT_REF",s[s.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",s[s.DT_INT32_REF=103]="DT_INT32_REF",s[s.DT_UINT8_REF=104]="DT_UINT8_REF",s[s.DT_INT16_REF=105]="DT_INT16_REF",s[s.DT_INT8_REF=106]="DT_INT8_REF",s[s.DT_STRING_REF=107]="DT_STRING_REF",s[s.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",s[s.DT_INT64_REF=109]="DT_INT64_REF",s[s.DT_BOOL_REF=110]="DT_BOOL_REF",s[s.DT_QINT8_REF=111]="DT_QINT8_REF",s[s.DT_QUINT8_REF=112]="DT_QUINT8_REF",s[s.DT_QINT32_REF=113]="DT_QINT32_REF",s[s.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",s[s.DT_QINT16_REF=115]="DT_QINT16_REF",s[s.DT_QUINT16_REF=116]="DT_QUINT16_REF",s[s.DT_UINT16_REF=117]="DT_UINT16_REF",s[s.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",s[s.DT_HALF_REF=119]="DT_HALF_REF",s[s.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",s[s.DT_VARIANT_REF=121]="DT_VARIANT_REF",s[s.DT_UINT32_REF=122]="DT_UINT32_REF",s[s.DT_UINT64_REF=123]="DT_UINT64_REF"})(Y||(Y={}));var ks;(function(s){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(s.CheckpointFormatVersion||(s.CheckpointFormatVersion={}))})(ks||(ks={}));const hs={};function Rf(s,e){const t={tfOpName:s,category:"custom",inputs:[],attrs:[],customExecutor:e};hs[s]=t}function En(s){return hs[s]}function Vf(s){delete hs[s]}function u(s,e,t,n,r){const a=e.inputParams[s];if(a&&a.inputIndexStart!==void 0){const i=a.inputIndexStart,c=a.inputIndexEnd===0?void 0:a.inputIndexEnd===void 0?i+1:a.inputIndexEnd,l=i<0?e.inputNames.length+i:i;if(a.type==="tensor")return W(e.inputNames[l],t,n,r);if(a.type==="tensors"){const y=e.inputs.slice(i,c);return e.inputNames.slice(i,c).filter((w,S)=>{var N;return((N=y[S])===null||N===void 0?void 0:N.op)!=="NoOp"}).map(w=>W(w,t,n,r))}const p=W(e.inputNames[l],t,n,r),h=p.dataSync();return a.type==="number"?h[0]:So(p.shape,h)}const o=e.attrParams[s];return o&&o.value}function W(s,e,t,n){const[r,a]=X(s,t);if(n!=null){const i=n.getHashTableHandleByName(r);if(i!=null)return i}const o=t.currentContextIds.find(i=>!!e[mt(r,i)]);return o!==void 0?e[mt(r,o)][a]:void 0}function Es(s,e,t){return e[mt(s,t.currentContextId)]}function le(s,e){const[t,n,r]=X(s,e);return[mt(t,e&&e.currentContextId),n,r]}function mt(s,e){return e?`${s}-${e}`:s}function X(s,e){if(s==="")return["",0,void 0];const t=e!=null&&e.parseNodeNameCache!=null;if(t){const a=e.parseNodeNameCache.get(s);if(a!=null)return a}const n=s.split(":");let r;if(n.length===1)r=[s,0,void 0];else{const a=n[0],o=n.length===3?n[1]:void 0,i=Number(n[n.length-1]);r=[a,i,o]}return t&&e.parseNodeNameCache.set(s,r),r}function nt(s,e,t){let n=u("pad",s,e,t);if(n==="explicit"){n=u("explicitPaddings",s,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let a=0;a<4;a++)r[a][0]=n[a*2],r[a][1]=n[a*2+1];return r}return n}function pe(s){return s.kept?s:Fe(s)}const cd=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ld=Object.freeze(Object.defineProperty({__proto__:null,json:cd},Symbol.toStringTag,{value:"Module"}));const pd=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsFinite",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsInf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],md=Object.freeze(Object.defineProperty({__proto__:null,json:pd},Symbol.toStringTag,{value:"Module"}));const hd=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],dd=Object.freeze(Object.defineProperty({__proto__:null,json:hd},Symbol.toStringTag,{value:"Module"}));const fd=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],yd=Object.freeze(Object.defineProperty({__proto__:null,json:fd},Symbol.toStringTag,{value:"Module"}));const gd=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniformInt",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number"},{tfName:"maxval",name:"maxval",type:"number"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],bd=Object.freeze(Object.defineProperty({__proto__:null,json:gd},Symbol.toStringTag,{value:"Module"}));const Nd=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],wd=Object.freeze(Object.defineProperty({__proto__:null,json:Nd},Symbol.toStringTag,{value:"Module"}));const Td=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Sd=Object.freeze(Object.defineProperty({__proto__:null,json:Td},Symbol.toStringTag,{value:"Module"}));const $d=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],_d=Object.freeze(Object.defineProperty({__proto__:null,json:$d},Symbol.toStringTag,{value:"Module"}));const kd=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Ed=Object.freeze(Object.defineProperty({__proto__:null,json:kd},Symbol.toStringTag,{value:"Module"}));const vd=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],Od=Object.freeze(Object.defineProperty({__proto__:null,json:vd},Symbol.toStringTag,{value:"Module"}));const Id=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BitwiseAnd",category:"logical",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}]}],Dd=Object.freeze(Object.defineProperty({__proto__:null,json:Id},Symbol.toStringTag,{value:"Module"}));const xd=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"MatrixBandPart",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"numLower",type:"tensor"},{start:1,name:"numUpper",type:"tensor"}]}],Ad=Object.freeze(Object.defineProperty({__proto__:null,json:xd},Symbol.toStringTag,{value:"Module"}));const Cd=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]}],Pd=Object.freeze(Object.defineProperty({__proto__:null,json:Cd},Symbol.toStringTag,{value:"Module"}));const Fd=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],Ld=Object.freeze(Object.defineProperty({__proto__:null,json:Fd},Symbol.toStringTag,{value:"Module"}));const zd=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]},{tfOpName:"TensorScatterUpdate",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],Rd=Object.freeze(Object.defineProperty({__proto__:null,json:zd},Symbol.toStringTag,{value:"Module"}));const Vd=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],Bd=Object.freeze(Object.defineProperty({__proto__:null,json:Vd},Symbol.toStringTag,{value:"Module"}));const jd=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Wd=Object.freeze(Object.defineProperty({__proto__:null,json:jd},Symbol.toStringTag,{value:"Module"}));const qd=[{tfOpName:"StaticRegexReplace",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"pattern",name:"pattern",type:"string"},{tfName:"rewrite",name:"rewrite",type:"string"},{tfName:"replace_global",name:"replaceGlobal",type:"bool"}]},{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Kd=Object.freeze(Object.defineProperty({__proto__:null,json:qd},Symbol.toStringTag,{value:"Module"}));const Hd=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"EnsureShape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Ud=Object.freeze(Object.defineProperty({__proto__:null,json:Hd},Symbol.toStringTag,{value:"Module"}));class vs{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[ld,md,dd,yd,bd,wd,Sd,_d,Ed,Od,Dd,Ad,Pd,Ld,Rd,Bd,Wd,Kd,Ud],t=[].concat(...e.map(n=>n.json));this.opMappers=t.reduce((n,r)=>(n[r.tfOpName]=r,n),{})}transformGraph(e,t={}){const n=e.node,r=[],a=[],o=[],i=n.reduce((S,N)=>(S[N.name]=this.mapNode(N),N.op.startsWith("Placeholder")?r.push(S[N.name]):N.op==="Const"?a.push(S[N.name]):(N.input==null||N.input.length===0)&&o.push(S[N.name]),S),{});let c=[];const l=[];let p={},h={};t!=null&&(p=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const y=Object.keys(i);y.forEach(S=>{const N=i[S];N.inputNames.forEach(($,E)=>{const[O,,_]=le($),D=i[O];if(D.outputs!=null){const k=D.outputs.indexOf(_);if(k!==-1){const P=`${O}:${k}`;N.inputNames[E]=P}}N.inputs.push(D),D.children.push(N)})}),Object.keys(h).length===0?y.forEach(S=>{const N=i[S];N.children.length===0&&l.push(N)}):Object.keys(h).forEach(S=>{const[N]=le(S),$=i[N];$!=null&&($.signatureKey=h[S],l.push($))}),Object.keys(p).length>0?Object.keys(p).forEach(S=>{const[N]=le(S),$=i[N];$&&($.signatureKey=p[S],c.push($))}):c=r;let g={};e.library!=null&&e.library.function!=null&&(g=e.library.function.reduce((S,N)=>(S[N.signature.name]=this.mapFunction(N),S),{}));const w={nodes:i,inputs:c,outputs:l,weights:a,placeholders:r,signature:t,functions:g};return o.length>0&&(w.initNodes=o),w}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,n)=>(t[e[n].name]=n,t),{})}mapNode(e){const t=En(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.slice(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(n.inputParams=t.inputs.reduce((r,a)=>(r[a.name]={type:a.type,inputIndexStart:a.start,inputIndexEnd:a.end},r),{})),t.attrs!=null&&(n.attrParams=t.attrs.reduce((r,a)=>{const o=a.type;let i;switch(a.type){case"string":i=Ct(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Ct(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":i=Bt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Bt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":i=Ft(e.attr,a.tfName,a.defaultValue||0),i===void 0&&a.tfDeprecatedName&&(i=Ft(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":i=Vt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Vt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":i=Pt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Pt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":i=Wt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Wt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":i=Rt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Rt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":i=jt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=jt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":i=Lt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Lt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":i=zt(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=zt(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":i=Os(e.attr,a.tfName,a.defaultValue),i===void 0&&a.tfDeprecatedName&&(i=Os(e.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${e.op}`)}return r[a.name]={value:i,type:o},r},{})),n}mapFunction(e){const t=e.nodeDef,n=[],r=[];let a={};t!=null&&(a=t.reduce((h,y)=>(h[y.name]=this.mapNode(y),y.op==="Const"&&r.push(h[y.name]),h),{}));const o=[],i=[];e.signature.inputArg.forEach(h=>{const[y]=le(h.name),g={name:y,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:ds(h.type),type:"dtype"}},children:[]};g.signatureKey=h.name,o.push(g),a[y]=g}),Object.keys(a).forEach(h=>{const y=a[h];y.inputNames.forEach((g,w)=>{const[S,,N]=le(g),$=a[S];if($.outputs!=null){const E=$.outputs.indexOf(N);if(E!==-1){const O=`${S}:${E}`;y.inputNames[w]=O}}y.inputs.push($),$.children.push(y)})});const l=e.ret;e.signature.outputArg.forEach(h=>{const[y,g]=le(l[h.name]),w=a[y];w!=null&&(w.defaultOutput=g,i.push(w))});const p=this.mapArgsToSignature(e);return{nodes:a,inputs:o,outputs:i,weights:r,placeholders:n,signature:p}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n),t),{}),outputs:e.signature.outputArg.reduce((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t),{})}}mapArgToTensorInfo(e,t){let n=e.name;return t!=null&&(n=t[n]),{name:n,dtype:e.type}}}function Gd(s){const e=ue().global;if(typeof e.atob<"u")return e.atob(s);if(typeof Buffer<"u")return new Buffer(s,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function vn(s,e){const t=Array.isArray(s)?String.fromCharCode.apply(null,s):Gd(s);return e?t:t.toLowerCase()}function Ct(s,e,t,n=!1){const r=s[e];return r!=null?vn(r.s,n):t}function Pt(s,e,t){const n=s[e];return n?n.b:t}function Ft(s,e,t){const n=s[e]||{},r=n.i!=null?n.i:n.f!=null?n.f:t;return typeof r=="number"?r:parseInt(r,10)}function ds(s){switch(typeof s=="string"&&(s=Y[s]),s){case Y.DT_FLOAT:case Y.DT_HALF:return"float32";case Y.DT_INT32:case Y.DT_INT64:case Y.DT_INT8:case Y.DT_UINT8:return"int32";case Y.DT_BOOL:return"bool";case Y.DT_DOUBLE:return"float32";case Y.DT_STRING:return"string";case Y.DT_COMPLEX64:case Y.DT_COMPLEX128:return"complex64";default:return null}}function Os(s,e,t){const n=s[e];return n&&n.func?n.func.name:t}function Lt(s,e,t){const n=s[e];return n&&n.type?ds(n.type):t}function zt(s,e,t){const n=s[e];return n&&n.list&&n.list.type?n.list.type.map(r=>ds(r)):t}function On(s){if(!s.unknownRank)return s.dim!=null?s.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Rt(s,e,t){const n=s[e];return n&&n.shape?On(n.shape):t}function Vt(s,e,t){const n=s[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function Bt(s,e,t,n=!1){const r=s[e];return r&&r.list&&r.list.s?r.list.s.map(a=>vn(a,n)):t}function jt(s,e,t){const n=s[e];return n&&n.list&&n.list.shape?n.list.shape.map(r=>On(r)):t}function Wt(s,e,t){const n=s[e];return n&&n.list&&n.list.b?n.list.b:t}class Jd{constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,a)=>(r[a]=this.getAttr(a),r),{}))}getInput(e){return W(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(n.tensor!=null)return W(e,this.tensorMap,this.context);if(n.i!=null||n.f!=null)return Ft(this.node.rawAttrs,e,t);if(n.s!=null)return Ct(this.node.rawAttrs,e,t);if(n.b!=null)return Pt(this.node.rawAttrs,e,t);if(n.shape!=null)return Rt(this.node.rawAttrs,e,t);if(n.type!=null)return Lt(this.node.rawAttrs,e,t);if(n.list!=null){if(n.list.i!=null||n.list.f!=null)return Vt(this.node.rawAttrs,e,t);if(n.list.s!=null)return Bt(this.node.rawAttrs,e,t);if(n.list.shape!=null)return jt(this.node.rawAttrs,e,t);if(n.list.b!=null)return Wt(this.node.rawAttrs,e,t);if(n.list.type!=null)return zt(this.node.rawAttrs,e,t)}return t}}const K=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:$o,abs:ee,acos:Co,acosh:Fo,add:j,addN:zo,all:Vo,any:jo,argMax:qo,argMin:Ho,asin:Go,asinh:Yo,atan:Qo,atan2:Mo,atanh:ti,avgPool:Hs,avgPool3d:ri,basicLSTMCell:li,batchNorm:Nt,batchNorm2d:fi,batchNorm3d:gi,batchNorm4d:Ni,batchToSpaceND:Us,bincount:Gs,bitwiseAnd:Si,booleanMaskAsync:Dp,broadcastArgs:_i,broadcastTo:st,buffer:Be,cast:B,ceil:Ei,clipByValue:Oi,clone:Fe,complex:Ve,concat:U,concat1d:Di,concat2d:Ai,concat3d:Pi,concat4d:Li,conv1d:Vi,conv2d:wt,conv2dTranspose:Wi,conv3d:Ki,conv3dTranspose:Ji,cos:Xi,cosh:Zi,cosineWindow:ls,cumprod:eu,cumsum:su,denseBincount:ru,depthToSpace:ou,depthwiseConv2d:ss,diag:cu,dilation2d:pu,div:H,divNoNan:fu,dot:gu,dropout:qp,einsum:Pe,elu:_o,enclosingPowerOfTwo:yn,ensureShape:wu,equal:Ys,erf:Su,euclideanNorm:vu,exp:Ee,expandDims:ye,expm1:xu,eye:Qs,fft:is,fill:dt,floor:Zs,floorDiv:ko,fused:rm,gather:Ms,gatherND:Bp,greater:St,greaterEqual:en,ifft:lt,imag:$t,image:xh,inTopKAsync:Hp,irfft:mn,isFinite:Bu,isInf:Wu,isNaN:Ku,leakyRelu:Eo,less:Dt,lessEqual:ns,linalg:Ah,linspace:Gu,localResponseNormalization:Yu,log:Ye,log1p:tn,logSigmoid:tc,logSoftmax:nc,logSumExp:nn,logicalAnd:it,logicalNot:rn,logicalOr:an,logicalXor:cc,losses:Ch,lowerBound:pc,matMul:x,max:Le,maxPool:on,maxPool3d:dc,maxPoolWithArgmax:yc,maximum:vo,mean:ut,meshgrid:bc,min:It,minimum:ct,mirrorPad:Tc,mod:$c,moments:kc,movingAverage:Cp,mul:v,multiRNNCell:vc,multinomial:Ic,neg:ie,norm:Tt,notEqual:un,oneHot:Ac,ones:$e,onesLike:Pc,op:f,outerProduct:Lc,pad:Me,pad1d:Vc,pad2d:jc,pad3d:qc,pad4d:Hc,pool:Xc,pow:Ut,prelu:Oo,print:Io,prod:Zc,raggedGather:el,raggedRange:sl,raggedTensorToTensor:rl,rand:ol,randomGamma:ll,randomNormal:ln,randomStandardNormal:hl,randomUniform:os,randomUniformInt:yl,range:Xe,real:Qe,reciprocal:Nl,relu:Qt,relu6:Do,reshape:T,reverse:ve,reverse1d:Sl,reverse2d:_l,reverse3d:El,reverse4d:Ol,rfft:us,round:pn,rsqrt:xl,scalar:A,scatterND:Fp,searchSorted:rs,selu:Cl,separableConv2d:Fl,setdiff1dAsync:zl,sigmoid:Ue,sign:Vl,signal:Dh,sin:jl,sinh:ql,slice:C,slice1d:Hl,slice2d:Gl,slice3d:Yl,slice4d:Ql,softmax:Ml,softplus:sn,spaceToBatchND:cn,sparse:Ph,sparseToDense:Rp,spectral:Ih,split:Ze,sqrt:vt,square:yt,squaredDifference:hn,squeeze:cs,stack:de,step:xo,stridedSlice:cp,string:Fh,sub:I,sum:L,tan:pp,tanh:Ot,tensor:ke,tensor1d:se,tensor2d:Je,tensor3d:dn,tensor4d:mp,tensor5d:hp,tensor6d:dp,tensorScatterUpdate:yp,tile:Ge,topk:bp,transpose:xt,truncatedNormal:wp,unique:Sp,unsortedSegmentSum:_p,unstack:De,upperBound:Ep,variable:vp,where:ge,whereAsync:fn,zeros:gt,zerosLike:Kt},Symbol.toStringTag,{value:"Module"}));const Yd=(s,e,t,n=K)=>{switch(s.op){case"BiasAdd":case"AddV2":case"Add":return[n.add(u("a",s,e,t),u("b",s,e,t))];case"AddN":return[n.addN(u("tensors",s,e,t))];case"FloorMod":case"Mod":return[n.mod(u("a",s,e,t),u("b",s,e,t))];case"Mul":return[n.mul(u("a",s,e,t),u("b",s,e,t))];case"RealDiv":case"Div":return[n.div(u("a",s,e,t),u("b",s,e,t))];case"DivNoNan":return[n.divNoNan(u("a",s,e,t),u("b",s,e,t))];case"FloorDiv":return[n.floorDiv(u("a",s,e,t),u("b",s,e,t))];case"Sub":return[n.sub(u("a",s,e,t),u("b",s,e,t))];case"Minimum":return[n.minimum(u("a",s,e,t),u("b",s,e,t))];case"Maximum":return[n.maximum(u("a",s,e,t),u("b",s,e,t))];case"Pow":return[n.pow(u("a",s,e,t),u("b",s,e,t))];case"SquaredDifference":return[n.squaredDifference(u("a",s,e,t),u("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Xd=(s,e,t,n=K)=>{switch(s.op){case"Abs":case"ComplexAbs":return[n.abs(u("x",s,e,t))];case"Acos":return[n.acos(u("x",s,e,t))];case"Acosh":return[n.acosh(u("x",s,e,t))];case"Asin":return[n.asin(u("x",s,e,t))];case"Asinh":return[n.asinh(u("x",s,e,t))];case"Atan":return[n.atan(u("x",s,e,t))];case"Atan2":return[n.atan2(u("x",s,e,t),u("y",s,e,t))];case"Atanh":return[n.atanh(u("x",s,e,t))];case"Ceil":return[n.ceil(u("x",s,e,t))];case"Complex":return[n.complex(u("real",s,e,t),u("imag",s,e,t))];case"Cos":return[n.cos(u("x",s,e,t))];case"Cosh":return[n.cosh(u("x",s,e,t))];case"Elu":return[n.elu(u("x",s,e,t))];case"Erf":return[n.erf(u("x",s,e,t))];case"Exp":return[n.exp(u("x",s,e,t))];case"Expm1":return[n.expm1(u("x",s,e,t))];case"Floor":return[n.floor(u("x",s,e,t))];case"Log":return[n.log(u("x",s,e,t))];case"Log1p":return[n.log1p(u("x",s,e,t))];case"Imag":return[n.imag(u("x",s,e,t))];case"Neg":return[n.neg(u("x",s,e,t))];case"Reciprocal":return[n.reciprocal(u("x",s,e,t))];case"Real":return[n.real(u("x",s,e,t))];case"Relu":return[n.relu(u("x",s,e,t))];case"Round":return[n.round(u("x",s,e,t))];case"Selu":return[n.selu(u("x",s,e,t))];case"Sigmoid":return[n.sigmoid(u("x",s,e,t))];case"Sin":return[n.sin(u("x",s,e,t))];case"Sign":return[n.sign(u("x",s,e,t))];case"Sinh":return[n.sinh(u("x",s,e,t))];case"Softplus":return[n.softplus(u("x",s,e,t))];case"Sqrt":return[n.sqrt(u("x",s,e,t))];case"Square":return[n.square(u("x",s,e,t))];case"Tanh":return[n.tanh(u("x",s,e,t))];case"Tan":return[n.tan(u("x",s,e,t))];case"ClipByValue":return[n.clipByValue(u("x",s,e,t),u("clipValueMin",s,e,t),u("clipValueMax",s,e,t))];case"Relu6":return[n.relu6(u("x",s,e,t))];case"Rsqrt":return[n.rsqrt(W(s.inputNames[0],e,t))];case"LeakyRelu":return[n.leakyRelu(u("x",s,e,t),u("alpha",s,e,t))];case"Prelu":return[n.prelu(u("x",s,e,t),u("alpha",s,e,t))];case"IsNan":return[n.isNaN(W(s.inputNames[0],e,t))];case"IsInf":return[n.isInf(W(s.inputNames[0],e,t))];case"IsFinite":return[n.isFinite(W(s.inputNames[0],e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function te(s,e,t=""){if(!(typeof s=="number"||typeof e=="number")){d(s.length===e.length,()=>t+` Shapes ${s} and ${e} must match`);for(let n=0;n<s.length;n++){const r=s[n],a=e[n];d(r<0||a<0||r===a,()=>t+` Shapes ${s} and ${e} must match`)}}}function Is(s){return!(typeof s=="number"||s.some(e=>e<0))}function He(s,e,t){let n=qt(s,t);const r=!Is(n);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${n}`);if(r&&e.forEach(a=>{n=qt(a.shape,n)}),!Is(n))throw new Error(`Non-fully-defined elementShape: ${n}`);return n}function qt(s,e){if(typeof s=="number")return e;if(typeof e=="number")return s;if(s.length!==e.length)throw new Error(`Incompatible ranks during merge: ${s} vs. ${e}`);const t=[];for(let n=0;n<s.length;++n){const r=s[n],a=e[n];if(r>=0&&a>=0&&r!==a)throw new Error(`Incompatible shape during merge: ${s} vs. ${e}`);t[n]=r>=0?r:a}return t}class Qd{constructor(e,t,n,r,a,o,i){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=r,this.identicalElementShapes=a,this.dynamicSize=o,this.clearAfterRead=i,this.tensors=[],this.closed_=!1,this.idTensor=A(0),me(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),te(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),n.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(n.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);n.tensor=t,me(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((n,r)=>this.write(n,t[r]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return ke([],[0].concat(this.elementShape));const n=this.readMany(e);return te(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),de(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return ke([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const n=this.readMany(t);return te(this.elementShape,n[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${n[0].shape})`),U(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error(`Max index must be < array size (${n}  vs. ${this.maxSize})`);this.writeMany(e,De(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let n=0;const r=e.map(c=>(n+=c,n));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const a=n===0?0:t.size/n,o=[];ne(()=>{t=T(t,[1,n,a]);for(let c=0;c<e.length;++c){const p=[0,c===0?0:r[c-1],0],h=[1,e[c],a];o[c]=T(C(t,p,h),this.elementShape)}return o});const i=[];for(let c=0;c<e.length;c++)i[c]=c;this.writeMany(i,o)}}class Ie{get id(){return this.idTensor.id}constructor(e,t,n,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=n,e?.forEach(a=>{if(n!==a.dtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${a.dtype}`);te(t,a.shape,"TensorList shape mismatch: "),me(a)}),this.idTensor=A(0),this.maxNumElements=r,me(this.idTensor)}copy(){return new Ie([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,n=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(n!==-1&&this.tensors.length!==n)throw new Error(`Operation expected a list with ${n} elements but got a list with ${this.tensors.length} elements.`);te(e,this.elementShape,"TensorList shape mismatch: ");const r=He(this.elementShape,this.tensors,e);return ne(()=>{const a=this.tensors.map(o=>T(o,r));return de(a,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const n=He(this.elementShape,this.tensors,e),r=this.tensors.pop();return r.kept=!1,te(r.shape,e,"TensorList shape mismatch: "),T(r,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(te(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");me(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Ie([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);te(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=He(this.elementShape,this.tensors,t);return T(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);te(this.elementShape,t.shape,"TensorList shape mismatch: "),me(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);te(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=He(this.elementShape,this.tensors,n);return e.length===0?ke([],[0].concat(r)):ne(()=>{const a=e.map(o=>T(this.tensors[o],r));return de(a,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);te(this.elementShape,t,"TensorList shape mismatch: ");const n=He(this.elementShape,this.tensors,t);return this.size()===0?ke([],[0].concat(n)):ne(()=>{const r=this.tensors.map(a=>T(a,n));return U(r,0)})}}function Zd(s,e,t){const n=s.dtype;if(s.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${s.shape}`);if(s.dtype!==t)throw new Error(`Invalid data types; op elements ${s.dtype}, but list elements ${t}`);const r=s.shape.slice(1);te(r,e,"TensorList shape mismatch: ");const a=De(s);return new Ie(a,e,n)}function Md(s,e,t,n){return new Ie([],s,e,n)}function ef(s,e,t,n){if(e.length!==s.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${s.shape[0]}`);const r=Math.max(...e);if(n!=null&&n!==-1&&r>=n)throw new Error(`Max index must be < array size (${r}  vs. ${n})`);const a=new Ie([],t,s.dtype,n),o=De(s,0);return e.forEach((i,c)=>{a.setItem(i,o[c])}),a}function tf(s,e,t){let n=0;const r=e.map(p=>(n+=p,n));if(n!==s.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${n}, and tensor's shape is: ${s.shape}`);const a=s.shape.slice(1),o=qt(a,t),i=n===0?0:s.size/n,c=ne(()=>{const p=[];s=T(s,[1,n,i]);for(let h=0;h<e.length;++h){const g=[0,h===0?0:r[h-1],0],w=[1,e[h],i];p[h]=T(C(s,g,w),o)}return s.dispose(),p}),l=new Ie([],t,s.dtype,e.length);for(let p=0;p<c.length;p++)l.setItem(p,c[p]);return l}const sf=async(s,e,t)=>{switch(s.op){case"If":case"StatelessIf":{const n=u("thenBranch",s,e,t),r=u("elseBranch",s,e,t),a=u("cond",s,e,t),o=u("args",s,e,t);return(await a.data())[0]?t.functionMap[n].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const n=u("body",s,e,t),r=u("cond",s,e,t),a=u("args",s,e,t),o=await t.functionMap[r].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap),i=a.map(p=>p.id);let c=await o[0].data();o.forEach(p=>{!p.kept&&i.indexOf(p.id)===-1&&p.dispose()});let l=a;for(;c[0];){const p=l;l=await t.functionMap[n].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);const h=l.map(g=>g.id);p.forEach(g=>{!g.kept&&i.indexOf(g.id)===-1&&h.indexOf(g.id)===-1&&g.dispose()});const y=await t.functionMap[r].executeFunctionAsync(l,t.tensorArrayMap,t.tensorListMap);c=await y[0].data(),y.forEach(g=>{!g.kept&&i.indexOf(g.id)===-1&&h.indexOf(g.id)===-1&&g.dispose()})}return l}case"LoopCond":{const n=u("pred",s,e,t);return[pe(n)]}case"Switch":{const n=u("pred",s,e,t);let r=u("data",s,e,t);return r.kept||(r=pe(r)),(await n.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const n=s.inputNames.find(r=>W(r,e,t)!==void 0);if(n){const r=W(n,e,t);return[pe(r)]}return}case"Enter":{const n=u("frameName",s,e,t),r=u("tensor",s,e,t);return t.enterFrame(n),[pe(r)]}case"Exit":{const n=u("tensor",s,e,t);return t.exitFrame(),[pe(n)]}case"NextIteration":{const n=u("tensor",s,e,t);return t.nextIteration(),[pe(n)]}case"TensorArrayV3":{const n=u("size",s,e,t),r=u("dtype",s,e,t),a=u("elementShape",s,e,t),o=u("dynamicSize",s,e,t),i=u("clearAfterRead",s,e,t),c=u("identicalElementShapes",s,e,t),l=u("name",s,e,t),p=new Qd(l,r,n,a,c,o,i);return t.addTensorArray(p),[p.idTensor,A(1)]}case"TensorArrayWriteV3":{const n=u("tensorArrayId",s,e,t),r=u("index",s,e,t),a=u("tensor",s,e,t),o=t.getTensorArray(n.id);return o.write(r,a),[o.idTensor]}case"TensorArrayReadV3":{const n=u("tensorArrayId",s,e,t),r=u("index",s,e,t);return[t.getTensorArray(n.id).read(r)]}case"TensorArrayGatherV3":{const n=u("tensorArrayId",s,e,t),r=u("indices",s,e,t),a=u("dtype",s,e,t);return[t.getTensorArray(n.id).gather(r,a)]}case"TensorArrayScatterV3":{const n=u("tensorArrayId",s,e,t),r=u("indices",s,e,t),a=u("tensor",s,e,t),o=t.getTensorArray(n.id);return o.scatter(r,a),[o.idTensor]}case"TensorArrayConcatV3":{const n=u("tensorArrayId",s,e,t),r=t.getTensorArray(n.id),a=u("dtype",s,e,t);return[r.concat(a)]}case"TensorArraySplitV3":{const n=u("tensorArrayId",s,e,t),r=u("tensor",s,e,t),a=u("lengths",s,e,t),o=t.getTensorArray(n.id);return o.split(a,r),[o.idTensor]}case"TensorArraySizeV3":{const n=u("tensorArrayId",s,e,t),r=t.getTensorArray(n.id);return[A(r.size(),"int32")]}case"TensorArrayCloseV3":{const n=u("tensorArrayId",s,e,t),r=t.getTensorArray(n.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const n=u("tensorListId",s,e,t),r=u("index",s,e,t),a=u("tensor",s,e,t),o=t.getTensorList(n.id);return o.setItem(r,a),[o.idTensor]}case"TensorListGetItem":{const n=u("tensorListId",s,e,t),r=u("index",s,e,t),a=u("elementShape",s,e,t),o=u("elementDType",s,e,t);return[t.getTensorList(n.id).getItem(r,a,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=u("indices",s,e,t),r=u("tensor",s,e,t),a=u("elementShape",s,e,t),o=u("numElements",s,e,t),i=ef(r,n,a,o);return t.addTensorList(i),[i.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const n=u("elementShape",s,e,t),r=u("elementDType",s,e,t);let a;s.op==="TensorListReserve"?a="numElements":a="maxNumElements";const o=u(a,s,e,t),i=s.op==="TensorListReserve"?-1:o,c=Md(n,r,o,i);return t.addTensorList(c),[c.idTensor]}case"TensorListGather":{const n=u("tensorListId",s,e,t),r=u("indices",s,e,t),a=u("elementShape",s,e,t),o=u("elementDType",s,e,t);return[t.getTensorList(n.id).gather(r,o,a)]}case"TensorListStack":{const n=u("tensorListId",s,e,t),r=u("elementShape",s,e,t),a=u("elementDType",s,e,t),o=u("numElements",s,e,t);return[t.getTensorList(n.id).stack(r,a,o)]}case"TensorListFromTensor":{const n=u("tensor",s,e,t),r=u("elementShape",s,e,t),a=u("elementDType",s,e,t),o=Zd(n,r,a);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const n=u("tensorListId",s,e,t),r=t.getTensorList(n.id),a=u("dtype",s,e,t),o=u("elementShape",s,e,t);return[r.concat(a,o)]}case"TensorListPushBack":{const n=u("tensorListId",s,e,t),r=u("tensor",s,e,t),a=t.getTensorList(n.id);return a.pushBack(r),[a.idTensor]}case"TensorListPopBack":{const n=u("tensorListId",s,e,t),r=u("elementShape",s,e,t),a=u("elementDType",s,e,t);return[t.getTensorList(n.id).popBack(r,a)]}case"TensorListSplit":{const n=u("tensor",s,e,t),r=u("elementShape",s,e,t),a=u("lengths",s,e,t),o=tf(n,a,r);return t.addTensorList(o),[o.idTensor]}case"TensorListLength":{const n=u("tensorListId",s,e,t),r=t.getTensorList(n.id);return[A(r.size(),"int32")]}case"TensorListResize":{const n=u("tensorListId",s,e,t),r=u("size",s,e,t),o=t.getTensorList(n.id).resize(r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};function Ds(s,e,t){const[n,r]=u("fusedOps",s,e,t),a=n==="biasadd",o=!a,i=r==="prelu",c=n==="fusedbatchnorm",l=u("numArgs",s,e,t);if(a){if(i&&l!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&a&&l!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const p=u("strides",s,e,t),h=nt(s,e,t),y=u("dataFormat",s,e,t).toUpperCase(),g=u("dilations",s,e,t);let[w,S]=u("args",s,e,t);o&&(S=w,w=void 0);const N=u("leakyreluAlpha",s,e,t);return{stride:p,pad:h,dataFormat:y,dilations:g,biasArg:w,preluArg:S,activationFunc:r,leakyreluAlpha:N}}const nf=(s,e,t,n=K)=>{switch(s.op){case"Conv1D":{const r=u("stride",s,e,t),a=u("pad",s,e,t),o=u("dataFormat",s,e,t).toUpperCase(),i=u("dilation",s,e,t);return[n.conv1d(u("x",s,e,t),u("filter",s,e,t),r,a,o,i)]}case"Conv2D":{const r=u("strides",s,e,t),a=nt(s,e,t),o=u("dataFormat",s,e,t).toUpperCase(),i=u("dilations",s,e,t);return[n.conv2d(u("x",s,e,t),u("filter",s,e,t),[r[1],r[2]],a,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:p,leakyreluAlpha:h}=Ds(s,e,t);return[n.fused.conv2d({x:u("x",s,e,t),filter:u("filter",s,e,t),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:p,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:a,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:p,leakyreluAlpha:h}=Ds(s,e,t);return[n.fused.depthwiseConv2d({x:u("x",s,e,t),filter:u("filter",s,e,t),strides:[r[1],r[2]],pad:a,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:p,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=u("outputShape",s,e,t),a=u("strides",s,e,t),o=nt(s,e,t);return[n.conv2dTranspose(u("x",s,e,t),u("filter",s,e,t),r,[a[1],a[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=u("strides",s,e,t),a=nt(s,e,t),o=u("dilations",s,e,t),i=u("dataFormat",s,e,t).toUpperCase();return[n.depthwiseConv2d(u("input",s,e,t),u("filter",s,e,t),[r[1],r[2]],a,i,[o[1],o[2]])]}case"Conv3D":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("dataFormat",s,e,t).toUpperCase(),i=u("dilations",s,e,t);return[n.conv3d(u("x",s,e,t),u("filter",s,e,t),[r[1],r[2],r[3]],a,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("kernelSize",s,e,t);return[n.avgPool(u("x",s,e,t),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPool":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("kernelSize",s,e,t);return[n.maxPool(u("x",s,e,t),[o[1],o[2]],[r[1],r[2]],a)]}case"MaxPoolWithArgmax":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("kernelSize",s,e,t),i=u("includeBatchInIndex",s,e,t),{result:c,indexes:l}=n.maxPoolWithArgmax(u("x",s,e,t),[o[1],o[2]],[r[1],r[2]],a,i);return[c,l]}case"AvgPool3D":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("kernelSize",s,e,t);return[n.avgPool3d(u("x",s,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"MaxPool3D":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("kernelSize",s,e,t);return[n.maxPool3d(u("x",s,e,t),[o[1],o[2],o[3]],[r[1],r[2],r[3]],a)]}case"Dilation2D":{const r=u("strides",s,e,t),a=u("pad",s,e,t),o=u("dilations",s,e,t),i=r[1],c=r[2],l=o[1],p=o[2];return[n.dilation2d(u("x",s,e,t),u("filter",s,e,t),[i,c],a,[l,p],"NHWC")]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const rf=(s,e,t,n=K)=>{switch(s.op){case"Fill":{const r=u("shape",s,e,t),a=u("dtype",s,e,t),o=u("value",s,e,t);return[n.fill(r,o,a)]}case"LinSpace":{const r=u("start",s,e,t),a=u("stop",s,e,t),o=u("num",s,e,t);return[n.linspace(r,a,o)]}case"Multinomial":{const r=u("logits",s,e,t),a=u("numSamples",s,e,t),o=u("seed",s,e,t);return[n.multinomial(r,a,o)]}case"OneHot":{const r=u("indices",s,e,t),a=u("depth",s,e,t),o=u("onValue",s,e,t),i=u("offValue",s,e,t),c=u("dtype",s,e,t);return[n.oneHot(r,a,o,i,c)]}case"Ones":return[n.ones(u("shape",s,e,t),u("dtype",s,e,t))];case"OnesLike":return[n.onesLike(u("x",s,e,t))];case"RandomStandardNormal":return[n.randomStandardNormal(u("shape",s,e,t),u("dtype",s,e,t),u("seed",s,e,t))];case"RandomUniform":return[n.randomUniform(u("shape",s,e,t),u("minval",s,e,t),u("maxval",s,e,t),u("dtype",s,e,t))];case"RandomUniformInt":return[n.randomUniformInt(u("shape",s,e,t),u("minval",s,e,t),u("maxval",s,e,t),u("seed",s,e,t))];case"Range":{const r=u("start",s,e,t),a=u("stop",s,e,t),o=u("step",s,e,t);return[n.range(r,a,o,u("dtype",s,e,t))]}case"TruncatedNormal":{const r=u("shape",s,e,t),a=u("mean",s,e,t),o=u("stdDev",s,e,t),i=u("seed",s,e,t);return[n.truncatedNormal(r,a,o,u("dtype",s,e,t),i)]}case"Zeros":return[n.zeros(u("shape",s,e,t),u("dtype",s,e,t))];case"ZerosLike":return[n.zerosLike(u("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function Et(s,e,t){const n=u("boxes",s,e,t),r=u("scores",s,e,t),a=u("maxOutputSize",s,e,t),o=u("iouThreshold",s,e,t),i=u("scoreThreshold",s,e,t),c=u("softNmsSigma",s,e,t);return{boxes:n,scores:r,maxOutputSize:a,iouThreshold:o,scoreThreshold:i,softNmsSigma:c}}const af=async(s,e,t,n,r=K)=>{switch(s.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:c,scoreThreshold:l,softNmsSigma:p}=Et(s,e,t),h=await r.image.nonMaxSuppressionWithScoreAsync(a,o,i,c,l,p);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:c,scoreThreshold:l}=Et(s,e,t),p=u("padToMaxOutputSize",s,e,t),h=await r.image.nonMaxSuppressionPaddedAsync(a,o,i,c,l,p);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:o,maxOutputSize:i,iouThreshold:c,scoreThreshold:l}=Et(s,e,t);return[await r.image.nonMaxSuppressionAsync(a,o,i,c,l)]}case"Where":{const a=r.cast(u("condition",s,e,t),"bool"),o=[await r.whereAsync(a)];return a.dispose(),o}case"ListDiff":return r.setdiff1dAsync(u("x",s,e,t),u("y",s,e,t));default:throw TypeError(`Node type ${s.op} is not implemented`)}};const of=(s,e,t,n=K)=>{switch(s.op){case"LowerBound":{const r=u("sortedSequence",s,e,t),a=u("values",s,e,t);return[n.lowerBound(r,a)]}case"TopKV2":{const r=u("x",s,e,t),a=u("k",s,e,t),o=u("sorted",s,e,t),i=n.topk(r,a,o);return[i.values,i.indices]}case"UpperBound":{const r=u("sortedSequence",s,e,t),a=u("values",s,e,t);return[n.upperBound(r,a)]}case"Unique":{const r=u("x",s,e,t),a=n.unique(r);return[a.values,a.indices]}case"UniqueV2":{const r=u("x",s,e,t),a=u("axis",s,e,t),o=n.unique(r,a);return[o.values,o.indices]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const uf=(s,e,t,n=K)=>{switch(s.op){case"Const":return e[s.name];case"PlaceholderWithDefault":const r=u("default",s,e,t);return[W(s.name,e,t)||r];case"Placeholder":return[W(s.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const p=u("x",s,e,t);return[pe(p)]}case"IdentityN":return u("x",s,e,t).map(p=>pe(p));case"Snapshot":const a=u("x",s,e,t);return[pe(a)];case"Shape":return[n.tensor1d(u("x",s,e,t).shape,"int32")];case"ShapeN":return u("x",s,e,t).map(p=>n.tensor1d(p.shape));case"Size":return[n.scalar(u("x",s,e,t).size,"int32")];case"Rank":return[n.scalar(u("x",s,e,t).rank,"int32")];case"NoOp":return[n.scalar(1)];case"Print":const o=u("x",s,e,t),i=u("data",s,e,t),c=u("message",s,e,t),l=u("summarize",s,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(c);for(let p=0;p<i.length;p++)console.log(Array.prototype.slice.call(i[p].dataSync()).slice(0,l));return[o];default:throw TypeError(`Node type ${s.op} is not implemented`)}};class cf{get id(){return this.handle.id}constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=A(0),this.tensorMap=new Map,me(this.handle)}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return A(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),ne(()=>{const r=De(t),a=n.length,o=r.length;d(a===o,()=>`The number of elements doesn't match, keys has ${a} elements, the values has ${o} elements.`);for(let i=0;i<a;i++){const c=n[i],l=r[i];me(l),this.tensorMap.set(c,l)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return ne(()=>{const r=[];for(let a=0;a<n.length;a++){const o=n[a],i=this.findWithDefault(o,t);r.push(i)}return de(r)})}findWithDefault(e,t){const n=this.tensorMap.get(e);return n??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}const lf=async(s,e,t,n)=>{switch(s.op){case"HashTable":case"HashTableV2":{const r=n.getHashTableHandleByName(s.name);if(r!=null)return[r];{const a=u("keyDType",s,e,t),o=u("valueDType",s,e,t),i=new cf(a,o);return n.addHashTable(s.name,i),[i.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const r=u("tableHandle",s,e,t,n),a=u("keys",s,e,t),o=u("values",s,e,t);return[await n.getHashTableById(r.id).import(a,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=u("tableHandle",s,e,t,n),a=u("keys",s,e,t),o=u("defaultValue",s,e,t);return[await n.getHashTableById(r.id).find(a,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=u("tableHandle",s,e,t,n);return[n.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const pf=(s,e,t,n=K)=>{switch(s.op){case"ResizeBilinear":{const r=u("images",s,e,t),a=u("size",s,e,t),o=u("alignCorners",s,e,t),i=u("halfPixelCenters",s,e,t);return[n.image.resizeBilinear(r,[a[0],a[1]],o,i)]}case"ResizeNearestNeighbor":{const r=u("images",s,e,t),a=u("size",s,e,t),o=u("alignCorners",s,e,t),i=u("halfPixelCenters",s,e,t);return[n.image.resizeNearestNeighbor(r,[a[0],a[1]],o,i)]}case"CropAndResize":{const r=u("image",s,e,t),a=u("boxes",s,e,t),o=u("boxInd",s,e,t),i=u("cropSize",s,e,t),c=u("method",s,e,t),l=u("extrapolationValue",s,e,t);return[n.image.cropAndResize(r,a,o,i,c,l)]}case"ImageProjectiveTransformV3":{const r=u("images",s,e,t),a=u("transforms",s,e,t),o=u("outputShape",s,e,t),i=u("fillValue",s,e,t),c=u("interpolation",s,e,t),l=u("fillMode",s,e,t);return[n.image.transform(r,a,c.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const mf=(s,e,t,n=K)=>{switch(s.op){case"Equal":return[n.equal(u("a",s,e,t),u("b",s,e,t))];case"NotEqual":return[n.notEqual(u("a",s,e,t),u("b",s,e,t))];case"Greater":return[n.greater(u("a",s,e,t),u("b",s,e,t))];case"GreaterEqual":return[n.greaterEqual(u("a",s,e,t),u("b",s,e,t))];case"Less":return[n.less(u("a",s,e,t),u("b",s,e,t))];case"LessEqual":return[n.lessEqual(u("a",s,e,t),u("b",s,e,t))];case"LogicalAnd":return[n.logicalAnd(u("a",s,e,t),u("b",s,e,t))];case"LogicalNot":return[n.logicalNot(u("a",s,e,t))];case"LogicalOr":return[n.logicalOr(u("a",s,e,t),u("b",s,e,t))];case"Select":case"SelectV2":return[n.where(u("condition",s,e,t),u("a",s,e,t),u("b",s,e,t))];case"BitwiseAnd":return[n.bitwiseAnd(u("a",s,e,t),u("b",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const hf=(s,e,t,n=K)=>{switch(s.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[n.matMul(u("a",s,e,t),u("b",s,e,t),u("transposeA",s,e,t),u("transposeB",s,e,t))];case"Einsum":return[n.einsum(u("equation",s,e,t),...u("tensors",s,e,t))];case"Transpose":return[n.transpose(u("x",s,e,t),u("perm",s,e,t))];case"_FusedMatMul":const[r,a]=u("fusedOps",s,e,t),o=r==="biasadd",i=a==="prelu",c=u("numArgs",s,e,t),l=u("leakyreluAlpha",s,e,t);if(o){if(i&&c!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&c!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[p,h]=u("args",s,e,t);return[n.fused.matMul({a:u("a",s,e,t),b:u("b",s,e,t),transposeA:u("transposeA",s,e,t),transposeB:u("transposeB",s,e,t),bias:p,activation:a,preluActivationWeights:h,leakyreluAlpha:l})];case"MatrixBandPart":return[n.linalg.bandPart(u("a",s,e,t),u("numLower",s,e,t),u("numUpper",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const df=(s,e,t,n=K)=>{switch(s.op){case"EuclideanNorm":return[n.euclideanNorm(u("x",s,e,t),u("axis",s,e,t),u("keepDims",s,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[n.batchNorm(u("x",s,e,t),u("mean",s,e,t),u("variance",s,e,t),u("offset",s,e,t),u("scale",s,e,t),u("epsilon",s,e,t))];case"FusedBatchNormV3":return[n.batchNorm(u("x",s,e,t),u("mean",s,e,t),u("variance",s,e,t),u("offset",s,e,t),u("scale",s,e,t),u("epsilon",s,e,t))];case"LRN":return[n.localResponseNormalization(u("x",s,e,t),u("radius",s,e,t),u("bias",s,e,t),u("alpha",s,e,t),u("beta",s,e,t))];case"Softmax":return[n.softmax(u("x",s,e,t))];case"LogSoftmax":return[n.logSoftmax(u("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const ff=(s,e,t,n=K)=>{switch(s.op){case"RaggedGather":{const{outputNestedSplits:r,outputDenseValues:a}=n.raggedGather(u("paramsNestedSplits",s,e,t),u("paramsDenseValues",s,e,t),u("indices",s,e,t),u("outputRaggedRank",s,e,t));return r.concat(a)}case"RaggedRange":{const{rtNestedSplits:r,rtDenseValues:a}=n.raggedRange(u("starts",s,e,t),u("limits",s,e,t),u("splits",s,e,t));return[r,a]}case"RaggedTensorToTensor":return[n.raggedTensorToTensor(u("shape",s,e,t),u("values",s,e,t),u("defaultValue",s,e,t),u("rowPartitionTensors",s,e,t),u("rowPartitionTypes",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const yf=(s,e,t,n=K)=>{switch(s.op){case"Max":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.max(u("x",s,e,t),i,c)]}case"Mean":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.mean(u("x",s,e,t),i,c)]}case"Min":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.min(u("x",s,e,t),i,c)]}case"Sum":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.sum(u("x",s,e,t),i,c)]}case"All":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.all(u("x",s,e,t),i,c)]}case"Any":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.any(u("x",s,e,t),i,c)]}case"ArgMax":{const i=u("axis",s,e,t);return[n.argMax(u("x",s,e,t),i)]}case"ArgMin":{const i=u("axis",s,e,t);return[n.argMin(u("x",s,e,t),i)]}case"Prod":{const i=u("axis",s,e,t),c=u("keepDims",s,e,t);return[n.prod(u("x",s,e,t),i,c)]}case"Cumprod":{const i=u("axis",s,e,t),c=u("exclusive",s,e,t),l=u("reverse",s,e,t);return[n.cumprod(u("x",s,e,t),i,c,l)]}case"Cumsum":{const i=u("axis",s,e,t),c=u("exclusive",s,e,t),l=u("reverse",s,e,t);return[n.cumsum(u("x",s,e,t),i,c,l)]}case"Bincount":const r=u("x",s,e,t),a=u("weights",s,e,t),o=u("size",s,e,t);return[n.bincount(r,a,o)];case"DenseBincount":{const i=u("x",s,e,t),c=u("weights",s,e,t),l=u("size",s,e,t),p=u("binaryOutput",s,e,t);return[n.denseBincount(i,c,l,p)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const gf=(s,e,t,n=K)=>{switch(s.op){case"ConcatV2":case"Concat":{const r=u("n",s,e,t),a=u("axis",s,e,t);let o=u("tensors",s,e,t);return o=o.slice(0,r),[n.concat(o,a)]}case"Gather":{const r=u("x",s,e,t),a=u("indices",s,e,t);return[n.gather(r,n.cast(a,"int32"),0)]}case"GatherV2":{const r=u("axis",s,e,t),a=u("batchDims",s,e,t),o=u("x",s,e,t),i=u("indices",s,e,t);return[n.gather(o,n.cast(i,"int32"),r,a)]}case"Reverse":{const r=u("dims",s,e,t),a=[];for(let i=0;i<r.length;i++)r[i]&&a.push(i);const o=u("x",s,e,t);return[n.reverse(o,a)]}case"ReverseV2":{const r=u("axis",s,e,t),a=u("x",s,e,t);return[n.reverse(a,r)]}case"Slice":{const r=u("begin",s,e,t),a=u("size",s,e,t);return[n.slice(u("x",s,e,t),r,a)]}case"StridedSlice":{const r=u("begin",s,e,t),a=u("end",s,e,t),o=u("strides",s,e,t),i=u("beginMask",s,e,t),c=u("endMask",s,e,t),l=u("ellipsisMask",s,e,t),p=u("newAxisMask",s,e,t),h=u("shrinkAxisMask",s,e,t),y=u("x",s,e,t);return[n.stridedSlice(y,r,a,o,i,c,l,p,h)]}case"Pack":return ne(()=>{const r=u("axis",s,e,t),a=u("tensors",s,e,t),o=a[0].shape,i=n.squeeze(a[0]).shape,c=a.map(l=>{const p=ze(l.shape,o);if(!p&&!ze(n.squeeze(l).shape,i))throw new Error("the input tensors shape does not match");return p?l:n.reshape(l,o)});return[n.stack(c,r)]});case"Unpack":{const r=u("axis",s,e,t),a=u("tensor",s,e,t);return n.unstack(a,r)}case"Tile":{const r=u("reps",s,e,t);return[n.tile(u("x",s,e,t),r)]}case"Split":case"SplitV":{const r=u("axis",s,e,t),a=u("numOrSizeSplits",s,e,t),o=u("x",s,e,t);return n.split(o,a,r)}case"ScatterNd":{const r=u("indices",s,e,t),a=u("values",s,e,t),o=u("shape",s,e,t);return[n.scatterND(r,a,o)]}case"GatherNd":{const r=u("x",s,e,t),a=u("indices",s,e,t);return[n.gatherND(r,a)]}case"SparseToDense":{const r=u("sparseIndices",s,e,t),a=u("outputShape",s,e,t),o=u("sparseValues",s,e,t),i=u("defaultValue",s,e,t);return[n.sparseToDense(r,o,a,o.dtype===i.dtype?i:n.cast(i,o.dtype))]}case"TensorScatterUpdate":{const r=u("indices",s,e,t),a=u("values",s,e,t),o=u("tensor",s,e,t);return[n.tensorScatterUpdate(o,r,a)]}default:throw TypeError(`Node type ${s.op} is not implemented`)}};const bf=(s,e,t,n=K)=>{switch(s.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:a,emptyRowIndicator:o,reverseIndexMap:i}=n.sparse.sparseFillEmptyRows(u("indices",s,e,t),u("values",s,e,t),u("denseShape",s,e,t),u("defaultValue",s,e,t));return[r,a,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:a}=n.sparse.sparseReshape(u("inputIndices",s,e,t),u("inputShape",s,e,t),u("newShape",s,e,t));return[r,a]}case"SparseSegmentMean":return[n.sparse.sparseSegmentMean(u("data",s,e,t),u("indices",s,e,t),u("segmentIds",s,e,t))];case"SparseSegmentSum":return[n.sparse.sparseSegmentSum(u("data",s,e,t),u("indices",s,e,t),u("segmentIds",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Nf=(s,e,t,n=K)=>{switch(s.op){case"FFT":return[n.fft(u("x",s,e,t))];case"IFFT":return[n.ifft(u("x",s,e,t))];case"RFFT":return[n.rfft(u("x",s,e,t))];case"IRFFT":return[n.irfft(u("x",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const wf=(s,e,t,n=K)=>{switch(s.op){case"StaticRegexReplace":return[n.string.staticRegexReplace(u("input",s,e,t),u("pattern",s,e,t),u("rewrite",s,e,t),u("replaceGlobal",s,e,t))];case"StringNGrams":{const{nGrams:r,nGramsSplits:a}=n.string.stringNGrams(u("data",s,e,t),u("dataSplits",s,e,t),u("separator",s,e,t),u("nGramWidths",s,e,t),u("leftPad",s,e,t),u("rightPad",s,e,t),u("padWidth",s,e,t),u("preserveShortSequences",s,e,t));return[r,a]}case"StringSplit":{const{indices:r,values:a,shape:o}=n.string.stringSplit(u("input",s,e,t),u("delimiter",s,e,t),u("skipEmpty",s,e,t));return[r,a,o]}case"StringToHashBucketFast":return[n.string.stringToHashBucketFast(u("input",s,e,t),u("numBuckets",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};const Tf=(s,e,t,n=K)=>{switch(s.op){case"Cast":return[n.cast(u("x",s,e,t),u("dtype",s,e,t))];case"ExpandDims":{const r=u("axis",s,e,t);return[n.expandDims(u("x",s,e,t),r)]}case"Squeeze":{const r=u("axis",s,e,t);return[n.squeeze(u("x",s,e,t),r)]}case"Reshape":return[n.reshape(u("x",s,e,t),u("shape",s,e,t))];case"EnsureShape":return[n.ensureShape(u("x",s,e,t),u("shape",s,e,t))];case"MirrorPad":return[n.mirrorPad(u("x",s,e,t),u("padding",s,e,t),u("mode",s,e,t))];case"PadV2":case"Pad":return[n.pad(u("x",s,e,t),u("padding",s,e,t),u("constantValue",s,e,t))];case"SpaceToBatchND":{const r=u("blockShape",s,e,t),a=u("paddings",s,e,t);return[n.spaceToBatchND(u("x",s,e,t),r,a)]}case"BatchToSpaceND":{const r=u("blockShape",s,e,t),a=u("crops",s,e,t);return[n.batchToSpaceND(u("x",s,e,t),r,a)]}case"DepthToSpace":{const r=u("blockSize",s,e,t),a=u("dataFormat",s,e,t).toUpperCase();return[n.depthToSpace(u("x",s,e,t),r,a)]}case"BroadcastTo":return[n.broadcastTo(u("x",s,e,t),u("shape",s,e,t))];case"BroadcastArgs":return[n.broadcastArgs(u("s0",s,e,t),u("s1",s,e,t))];default:throw TypeError(`Node type ${s.op} is not implemented`)}};function xs(s,e,t,n,r=ne){const a=((o,i,c)=>{switch(o.category){case"arithmetic":return r(()=>Yd(o,i,c));case"basic_math":return r(()=>Xd(o,i,c));case"control":return sf(o,i,c);case"convolution":return r(()=>nf(o,i,c));case"creation":return r(()=>rf(o,i,c));case"dynamic":return af(o,i,c);case"evaluation":return r(()=>of(o,i,c));case"image":return r(()=>pf(o,i,c));case"graph":return r(()=>uf(o,i,c));case"logical":return r(()=>mf(o,i,c));case"matrices":return r(()=>hf(o,i,c));case"normalization":return r(()=>df(o,i,c));case"ragged":return r(()=>ff(o,i,c));case"reduction":return r(()=>yf(o,i,c));case"slice_join":return r(()=>gf(o,i,c));case"sparse":return r(()=>bf(o,i,c));case"spectral":return r(()=>Nf(o,i,c));case"string":return r(()=>wf(o,i,c));case"transformation":return r(()=>Tf(o,i,c));case"hash_table":return lf(o,i,c,n);case"custom":const l=En(o.op);if(l&&l.customExecutor)return l.customExecutor(new Jd(o,i,c));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(s,e,t);return ot(a)?a.then(o=>[].concat(o)):[].concat(a)}class As{constructor(e={},t={},n={},r={},a){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=r,this.parseNodeNameCache=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function Cs(s,e,t,n){const r=new Set,a=[];let o=null,i=null;const c=new Set,l=new Set(Object.keys(s).map(y=>X(y)[0]));n=n||[];const p=new Set(n.map(y=>X(y.name)[0])),h=[...e];for(;h.length>0;){const y=h.pop();if((Se(y)||If(y)||Df(y))&&o==null&&(o=y,i=o.children.map(g=>g.name).filter(g=>r.has(g))),r.add(y.name),t[y.name]==null&&!l.has(y.name)&&!p.has(y.name)){if(y.inputs.length===0){a.push(y.name);continue}y.inputs.forEach(g=>{c.has(g.name)||(c.add(g.name),h.push(g))})}}return{inputs:s,outputs:e,usedNodes:r,missingInputs:a,dynamicNode:o,syncInputs:i}}function Sf(s,e){const{usedNodes:t,inputs:n}=e,r=Object.keys(n).map(N=>X(N)[0]).map(N=>s.nodes[N]),a=s.initNodes||[],o=N=>t.has(typeof N=="string"?N:N.name);function i(N){return[...new Map(N.map($=>[$.name,$])).values()]}const c=i([...r,...s.weights,...a]).filter(o),l=i([...c,...Object.values(s.nodes)]).filter(o),p=new Map(l.map(N=>[N.name,N])),h={};for(const N of l){h[N.name]=h[N.name]||0;for(const $ of N.children)o($)||(h[$.name]=Number.POSITIVE_INFINITY),h[$.name]=(h[$.name]||0)+1}const y=Object.entries(h).filter(([,N])=>N===0).map(([N])=>N),g=[...y];for(;y.length>0;){const N=y.pop(),$=p.get(N);for(const E of $.children.filter(o))--h[E.name]===0&&(g.push(E.name),y.push(E.name))}const w=g.map(N=>p.get(N)),S=$f(w,c);return _f(S,c),S}function $f(s,e){const t=new Map(s.map(o=>[o.name,o])),n=e.map(o=>o.name),r=new Set(n);for(;n.length>0;){const o=n.pop(),i=t.get(o);for(const c of i.children)!t.has(c.name)||r.has(c.name)||(r.add(c.name),n.push(c.name))}return s.filter(o=>r.has(o.name))}class tt extends Error{constructor(e){super(`NodesExecutionOrderError: ${e}`)}}function _f(s,e){const t=new Map(s.map((i,c)=>[i.name,c])),n=new Set(e.map(i=>i.name)),r=i=>n.has(typeof i=="string"?i:i.name),a=new Set(s.map(i=>i.name)),o=i=>a.has(typeof i=="string"?i:i.name);for(const i of s){for(const c of i.children.filter(o)){if(!t.has(c.name))throw new tt(`Child ${c.name} of node ${i.name} is unreachable.`);if(t.get(i.name)>t.get(c.name))throw new tt(`Node ${i.name} is scheduled to run after its child ${c.name}.`)}if(!r(i))for(const c of i.inputs){if(!t.has(c.name))throw new tt(`Input ${c.name} of node ${i.name} is unreachable.`);if(t.get(c.name)>t.get(i.name))throw new tt(`Node ${i.name} is scheduled to run before its input ${c.name}.`)}}}function kf(s){const e=new Map(s.map((i,c)=>[i.name,c])),t=Number.MAX_SAFE_INTEGER,n=s.map((i,c)=>Se(i)?t:c),r=i=>{const c=n[e.get(i.name)];return c??-1},a=s.map((i,c)=>i.children.map(r).reduce((l,p)=>Math.max(l,p),n[c])),o=new Map;for(let i=0;i<s.length;++i){const c=a[i];if(c===t)continue;const l=s[i],p=s[c];o.has(p.name)||o.set(p.name,[]),o.get(p.name).push(l)}return o}const Ef=new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),vf=new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),Of=new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function Se(s){return Ef.has(s.op)}function If(s){return vf.has(s.op)}function Df(s){return Of.has(s.op)}class ht{get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(n=>e[n].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this.parseNodeNameCache=new Map,this._weightMap={},this.SEPARATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(n=>{this._functionExecutorMap[n]=new ht(e.functions[n],this)})}getCompilationKey(e,t){const n=e.map(a=>a.name).sort(),r=t.map(a=>a.name).sort();return n.join(this.SEPARATOR)+"--"+r.join(this.SEPARATOR)}compile(e,t){const n=Cs(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:a,syncInputs:o}=n;if(a!=null)throw new Error(`This execution contains the node '${a.name}', which has the dynamic op '${a.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const l=t.map(h=>h.name),p=Object.keys(e);throw new Error(`Cannot compute the outputs [${l}] from the provided inputs [${p}]. Missing the following inputs: [${r}]`)}const i=Sf(this.graph,n),c=kf(i);return{orderedNodes:i,nodeLiveUntilMap:c}}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return me(t),t}cloneTensorList(e){return e?e.map(n=>this.cloneAndKeepTensor(n)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,n])=>[t,this.cloneTensorList(n)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=n.map(y=>this.graph.nodes[X(y)[0]]),a=t.map(y=>X(y)[0]),o=new Set(a);let i=a.map(y=>this.graph.nodes[y]);i.length===0&&(i=this._outputs);const c=this.getCompilationKey(r,i);let l=this.compiledMap.get(c);l==null&&(l=this.compile(e,i),this.compiledMap.set(c,l));try{this.keepIntermediateTensors=ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const p={},h={};return ne(()=>{const y=new As(this.weightMap,p,h,this.functionExecutorMap,this.parseNodeNameCache),g=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach($=>{const[E,O]=X($,y),_=[];_[O]=e[$],g[E]=_,this.keepIntermediateTensors&&(this.clonedTensorsMap[E]=this.cloneTensorList(_))});const w=this.getFrozenTensorIds(g),{orderedNodes:S,nodeLiveUntilMap:N}=l;for(const $ of S){if(g[$.name])continue;const E=xs($,g,y,this._resourceManager);if(ot(E))throw new Error(`The execution of the op '${$.op}' returned a promise. Please use model.executeAsync() instead.`);g[$.name]=E,this.keepIntermediateTensors&&(this.clonedTensorsMap[$.name]=this.cloneTensorList(E)),this.checkTensorForDisposalWithNodeLiveUntilInfo($,g,y,w,o,N.get($.name))}return this.parent==null&&y.dispose(w),t.map($=>W($,g,y))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(n=>e[n]).map(n=>n.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,n,r,a,o,i){if(!(Se(t)||o.has(e))){for(const c of n[e])c!=null&&(i[c.id]=(i[c.id]||0)+t.children.length);for(const c of t.inputs){if(Se(c))continue;const l=Es(c.name,n,r);if(l!=null)for(const p of l){if(!p||p.kept||a.has(p.id))continue;const h=i[p.id];h===1?(p.dispose(),delete i[p.id]):h!=null&&i[p.id]--}}}}checkTensorForDisposalWithNodeLiveUntilInfo(e,t,n,r,a,o){function i(c){return Se(c)||a.has(c.name)}if(!(Se(e)||o==null))for(const c of o){if(i(c))continue;const l=Es(c.name,t,n);for(const p of l)!p||p.kept||r.has(p.id)||p.dispose()}}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,n=!1,r={},a={}){this.disposeIntermediateTensors(),n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ue().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(y){this.keepIntermediateTensors=!1,console.warn(y.message)}const o=new As(this.weightMap,r,a,this.functionExecutorMap,this.parseNodeNameCache);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const i=await this.executeWithControlFlow(e,o,t,n),c=t.map(y=>W(y,i,o)),l=c.map(y=>y.id),p=Object.keys(e).map(y=>e[y].id),h=new Set([...l,...p,...this.weightIds]);return Object.values(i).forEach(y=>{y.forEach(g=>{g&&!g.isDisposed&&!h.has(g.id)&&g.dispose()})}),this.parent==null&&o.dispose(h),c}async executeFunctionAsync(e,t,n){const r=e.reduce((a,o,i)=>(a[this.inputs[i].name]=o,a),{});return this._executeAsync(r,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,r){const a=Object.keys(e),o=a.map(_=>this.graph.nodes[X(_)[0]]),i=n.map(_=>X(_)[0]),c=new Set(i);let l=i.map(_=>this.graph.nodes[_]);l.length===0&&(l=this._outputs);const{usedNodes:p,missingInputs:h,dynamicNode:y,syncInputs:g}=Cs(e,l,this.weightMap,this._initNodes),w=[...o,...this.graph.weights,...this._initNodes||[]].map(_=>({node:_,contexts:t.currentContext})),S=Object.assign({},this.weightMap);Object.keys(e).forEach(_=>{const[D,k]=X(_),P=[];P[k]=e[_],S[D]=P});const N={},$=this.getFrozenTensorIds(S),E={};for(;w.length>0;){const _=this.processStack(o,w,t,S,E,$,c,N,p);await Promise.all(_)}y==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const O=l.filter(_=>!Se(_)&&!W(_.name,S,t)).map(_=>_.name);if(O.length>0){let _="";throw y!=null&&(_=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${g}]`),new Error(`Cannot compute the outputs [${O}] from the provided inputs [${a}]. Consider providing the following inputs: [${h}]. ${_}`)}return S}processStack(e,t,n,r,a,o,i,c,l){const p=[];for(;t.length>0;){const h=t.pop();n.currentContext=h.contexts;let y="";if(h.node.op==="Enter"&&u("isConstant",h.node,r,n)&&([y]=le(h.node.name,n)),r[h.node.name]==null){const g=xs(h.node,r,n,this._resourceManager);y||([y]=le(h.node.name,n));const w=n.currentContext;ot(g)?p.push(g.then(S=>(r[y]=S,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(S)),n.currentContext=w,this.checkTensorForDisposal(y,h.node,r,n,o,i,c),this.processChildNodes(h.node,t,n,r,a,l),S))):(r[y]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[y]=this.cloneTensorList(g)),this.checkTensorForDisposal(y,h.node,r,n,o,i,c),this.processChildNodes(h.node,t,n,r,a,l))}else this.processChildNodes(h.node,t,n,r,a,l)}return p}processChildNodes(e,t,n,r,a,o){e.children.forEach(i=>{const[c]=le(i.name,n);a[c]||!o.has(i.name)||(i.op==="Merge"?i.inputNames.some(l=>!!W(l,r,n))&&(a[c]=!0,t.push({contexts:n.currentContext,node:i})):i.inputNames.every(l=>!!W(l,r,n))&&(a[c]=!0,t.push({contexts:n.currentContext,node:i})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const n=e[t],[r]=X(t),a=this.graph.nodes[r];if(a.attrParams.shape&&a.attrParams.shape.value){const o=a.attrParams.shape.value,i=o.length===n.shape.length&&n.shape.every((c,l)=>o[l]===-1||o[l]===c);d(i,()=>`The shape of dict['${a.name}'] provided in model.execute(dict) must be [${o}], but was [${n.shape}]`)}a.attrParams.dtype&&a.attrParams.dtype.value&&d(n.dtype===a.attrParams.dtype.value,()=>`The dtype of dict['${a.name}'] provided in model.execute(dict) must be ${a.attrParams.dtype.value}, but was ${n.dtype}`)})}mapInputs(e){var t,n;const r={};for(const a in e){const o=(n=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||n===void 0?void 0:n[a];o!=null?r[o.name]=e[a]:r[a]=e[a]}return r}checkInputs(e){const t=Object.keys(e).filter(n=>{const[r]=X(n);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var n,r;const a=(r=(n=this._signature)===null||n===void 0?void 0:n.outputs)===null||r===void 0?void 0:r[t];return a!=null?a.name:t},{})}checkOutputs(e){e.forEach(t=>{const[n]=X(t);if(!this.graph.nodes[n])throw new Error(`The output '${t}' is not found in the graph`)})}}class xf{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Af="?tfjs-format=file",Cf="model.json";class In{get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}constructor(e,t={},n=$n){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,t==null&&(this.loadOptions={}),this.resourceManager=new xf}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return ot(e)?e.then(t=>t.getWeightStream==null?this.loadSync(t):this.loadStreaming(t)):this.loadSync(e)}loadSync(e){const t=this.io.decodeWeights(e.weightData,e.weightSpecs);return this.loadWithWeightMap(e,t)}async loadStreaming(e){if(e.getWeightStream==null)throw new Error("Model artifacts missing streamWeights function");const t=await js(e.getWeightStream(),e.weightSpecs);return this.loadWithWeightMap(e,t)}loadWithWeightMap(e,t){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const a=this.artifacts.userDefinedMetadata;a.signature!=null&&(r=a.signature),a.structuredOutputKeys!=null&&(this.structuredOutputKeys=a.structuredOutputKeys)}if(this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`,this.executor=new ht(vs.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(t),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const a=vs.Instance.transformGraph(e.modelInitializer);this.initializer=new ht(a),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const n=this.io.getSaveHandlers(e);if(n.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(n.length>1)throw new Error(`Found more than one (${n.length}) save handlers for URL '${e}'`);e=n[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof _e?[e]:e,n={};return t.forEach((r,a)=>n[this.structuredOutputKeys[a]]=r),n}return e}predict(e,t){const n=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(n)}async predictAsync(e,t){const n=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(n)}normalizeInputs(e){var t;if(!(e instanceof _e)&&!Array.isArray(e)){const a=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(a!=null)for(const o in a){const i=a[o];i.resourceId!=null&&(e[o]=this.resourceIdToCapturedInput[i.resourceId])}return e}e=Array.isArray(e)?e:[e];const n=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+n!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-n} non-resource placeholders, while there are ${e.length} input tensors provided.`);let r=0;return this.inputNodes.reduce((a,o)=>{var i,c,l;const p=(l=(c=(i=this.signature)===null||i===void 0?void 0:i.inputs)===null||c===void 0?void 0:c[o])===null||l===void 0?void 0:l.resourceId;return p!=null?a[o]=this.resourceIdToCapturedInput[p]:a[o]=e[r++],a},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,n=Object.keys(t);for(let r=0;r<n.length;r++){const a=n[r],o=t[a];this.resourceIdToCapturedInput[o.resourceId]=e[r]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,n)=>(t[n]=[e[n]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&Rs(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function Bf(s,e={},t=$n){if(s==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof s=="string"&&(s=Pf(s));const n=new In(s,e,t);return await n.load(),n}function jf(s){if(s==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(s instanceof Array){const[n,r]=s;if(!n)throw new Error("modelJSON must be the first element of the array");if(!r||!(r instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in n))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in n))throw new Error("Model JSON is missing 'weightsManifest'");const a=at(n.weightsManifest),o=Ws(n,a,r);e=pt(o)}else if("load"in s)e=s;else if("modelTopology"in s&&"weightSpecs"in s&&"weightData"in s)e=pt(s);else throw new Error("Unknown model format");const t=new In(e);return t.load(),t}function Pf(s){return s.endsWith("/")||(s=s+"/"),`${s}${Cf}${Af}`}export{jo as $,jl as A,ql as B,su as C,Qp as D,Mp as E,xl as F,Ge as G,de as H,_p as I,St as J,Ys as K,Dt as L,$e as M,Zs as N,De as O,Ye as P,eu as Q,ve as R,rn as S,Xi as T,Zi as U,Me as V,Us as W,Ms as X,Co as Y,Fo as Z,Vo as _,Je as a,Gl as a$,qo as a0,Ho as a1,Go as a2,Yo as a3,Qo as a4,Mo as a5,ti as a6,Hs as a7,Nt as a8,Ei as a9,It as aA,ct as aB,Tc as aC,$c as aD,Tt as aE,un as aF,Pc as aG,Xc as aH,Zc as aI,Nl as aJ,Pm as aK,Lm as aL,us as aM,pn as aN,Cl as aO,Fl as aP,Vl as aQ,Ml as aR,sn as aS,hn as aT,cp as aU,pp as aV,Ot as aW,bp as aX,Sp as aY,Ql as aZ,Yl as a_,Vi as aa,Wi as ab,ou as ac,ss as ad,pu as ae,fu as af,gu as ag,Su as ah,vu as ai,xu as aj,is as ak,lt as al,mn as am,Bu as an,Wu as ao,Ku as ap,Yu as aq,tc as ar,nc as as,nn as at,tn as au,an as av,cc as aw,on as ax,Le as ay,ut as az,C as b,Sl as b$,Hl as b0,ln as b1,nm as b2,Li as b3,Pi as b4,Ai as b5,Di as b6,qp as b7,os as b8,wp as b9,li as bA,Gs as bB,Si as bC,_i as bD,cu as bE,Pe as bF,wu as bG,$t as bH,Gu as bI,pc as bJ,yc as bK,bc as bL,vc as bM,Ic as bN,Lc as bO,Vc as bP,jc as bQ,qc as bR,Hc as bS,el as bT,sl as bU,rl as bV,ol as bW,ll as bX,hl as bY,yl as bZ,Qe as b_,Qs as ba,Ah as bb,vp as bc,Jh as bd,Kh as be,Ji as bf,Yp as bg,Ki as bh,kc as bi,fi as bj,gi as bk,Ni as bl,dc as bm,ri as bn,Xe as bo,ru as bp,zf as bq,$n as br,J as bs,Ch as bt,Ih as bu,rm as bv,Dh as bw,Ph as bx,Fh as by,zo as bz,se as c,_l as c0,El as c1,Ol as c2,zl as c3,dn as c4,mp as c5,hp as c6,dp as c7,yp as c8,Ep as c9,fn as ca,Dp as cb,Cp as cc,Fp as cd,rs as ce,Rp as cf,Bp as cg,yn as ch,ls as ci,Hp as cj,In as ck,jf as cl,Vf as cm,Rf as cn,Ee as d,ye as e,id as f,U as g,Oi as h,xh as i,xt as j,cn as k,Bf as l,x as m,ie as n,Ac as o,it as p,en as q,ns as r,cs as s,ad as t,Ze as u,Gp as v,ge as w,Js as x,wt as y,Ui as z};
