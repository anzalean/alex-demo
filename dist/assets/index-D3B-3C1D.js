import{l as _n,L as Ln}from"./long-CgdJXaQy.js";const On=1e-7,Un=1e-4;class ea{constructor(t,n){this.backend=t,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,n){this.dataIdsCount++,this.data.set(t,n)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}}class Gn{refCount(t){return L("refCount")}incRef(t){return L("incRef")}timerAvailable(){return!0}time(t){return L("time")}read(t){return L("read")}readSync(t){return L("readSync")}readToGPU(t,n){return L("readToGPU")}numDataIds(){return L("numDataIds")}disposeData(t,n){return L("disposeData")}write(t,n,s){return L("write")}move(t,n,s,r,o){return L("move")}createTensorFromGPUData(t,n,s){return L("createTensorFromGPUData")}memory(){return L("memory")}floatPrecision(){return L("floatPrecision")}epsilon(){return this.floatPrecision()===32?On:Un}dispose(){return L("dispose")}}function L(e){throw new Error(`'${e}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function Ue(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Lt(e,t,n)}function zn(e,t){if(e.length!==t.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${e.length}Second array length was ${t.length}`);let n=e.length,s=0;for(;n>0;)s=Math.random()*n|0,n--,Lt(e,n,s),Lt(t,n,s)}function Wn(e,t,n){return Math.max(e,Math.min(t,n))}function jn(e){return e%2===0?e:e+1}function Lt(e,t,n){const s=e[t];e[t]=e[n],e[n]=s}function Vn(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function qn(e,t){const n=Math.random();return t*n+(1-n)*e}function Kn(e,t){let n=0;for(let s=0;s<e.length;s++){const r=Number(e[s])-Number(t[s]);n+=r*r}return n}function b(e,t){if(!e)throw new Error(typeof t=="string"?t:t())}function Dt(e,t,n=""){b(Wt(e,t),()=>n+` Shapes ${e} and ${t} must match`)}function Hn(e){b(e!=null,()=>"The input to the tensor constructor must be a non-null value.")}function C(e){if(e.length===0)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Xn(e){return e.length===0}function Jn(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==null&&t[n]!==null&&e[n]!==t[n])return!1;return!0}function Wt(e,t){if(e===t)return!0;if(e==null||t==null||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Ot(e){return e%1===0}function Yn(e){if(Math.tanh!=null)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function Zn(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Qn(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return Ue(t),t}function xt(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function ts(e,t=r=>0,n,s){return new Promise((r,o)=>{let a=0;const i=()=>{if(e()){r();return}a++;const c=t(a);if(n!=null&&a>=n){o();return}s!=null?s(i,c):setTimeout(i,c)};i()})}function es(e,t){let n=1,s=-1;for(let o=0;o<e.length;++o)if(e[o]>=0)n*=e[o];else if(e[o]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${o}`);s=o}else if(e[o]<0)throw Error(`Shapes can not be < 0. Found ${e[o]} at dim ${o}`);if(s===-1){if(t>0&&t!==n)throw Error(`Size(${t}) must match the product of shape ${e}`);return e}if(n===0)throw Error(`Cannot infer the missing size in [${e}] when there are 0 elements`);if(t%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${n}`);const r=e.slice();return r[s]=t/n,r}function Ge(e,t){const n=t.length;return e=e==null?t.map((s,r)=>r):[].concat(e),b(e.every(s=>s>=-n&&s<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${e}`),b(e.every(s=>Ot(s)),()=>`All values in axis param must be integers but got axis ${e}`),e.map(s=>s<0?n+s:s)}function ns(e,t){const n=[],s=[],r=t!=null&&Array.isArray(t)&&t.length===0,o=t==null||r?null:Ge(t,e).sort();let a=0;for(let i=0;i<e.length;++i){if(o!=null){if(o[a]===i&&e[i]!==1)throw new Error(`Can't squeeze axis ${i} since its dim '${e[i]}' is not 1`);(o[a]==null||o[a]>i)&&e[i]===1&&(n.push(e[i]),s.push(i)),o[a]<=i&&a++}e[i]!==1&&(n.push(e[i]),s.push(i))}return{newShape:n,keptDims:s}}function ss(e,t){return we(e,t)}function we(e,t){let n=null;if(e==null||e==="float32")n=new Float32Array(t);else if(e==="int32")n=new Int32Array(t);else if(e==="bool")n=new Uint8Array(t);else if(e==="string")n=new Array(t);else throw new Error(`Unknown data type ${e}`);return n}function ze(e,t){for(let n=0;n<e.length;n++){const s=e[n];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${t} being uploaded contains ${s}.`)}}function We(e){return e==="bool"||e==="complex64"||e==="float32"||e==="int32"||e==="string"}function rs(e,t){return!(t==="complex64"||t==="float32"&&e!=="complex64"||t==="int32"&&e!=="float32"&&e!=="complex64"||t==="bool"&&e==="bool")}function Ut(e){if(e==="float32"||e==="int32")return 4;if(e==="complex64")return 8;if(e==="bool")return 1;throw new Error(`Unknown dtype ${e}`)}function je(e){if(e==null)return 0;let t=0;return e.forEach(n=>t+=n.length),t}function jt(e){return typeof e=="string"||e instanceof String}function Ve(e){return typeof e=="boolean"}function qe(e){return typeof e=="number"}function Rt(e){return Array.isArray(e)?Rt(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":qe(e)?"float32":jt(e)?"string":Ve(e)?"bool":"float32"}function J(e){return!!(e&&e.constructor&&e.call&&e.apply)}function os(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function Ft(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let s=t-3;s>=0;--s)n[s]=n[s+1]*e[s+1];return n}function Ke(e,t,n,s=!1){const r=new Array;if(t.length===1){const o=t[0]*(s?2:1);for(let a=0;a<o;a++)r[a]=n[e+a]}else{const o=t[0],a=t.slice(1),i=a.reduce((c,l)=>c*l)*(s?2:1);for(let c=0;c<o;c++)r[c]=Ke(e+c*i,a,n,s)}return r}function dt(e,t,n=!1){if(e.length===0)return t[0];const s=e.reduce((r,o)=>r*o)*(n?2:1);if(s===0)return[];if(s!==t.length)throw new Error(`[${e}] does not match the input size ${t.length}${n?" for a complex tensor":""}.`);return Ke(0,e,t,n)}function as(e,t){if(Array.isArray(e))return e;if(t==="float32")return e instanceof Float32Array?e:new Float32Array(e);if(t==="int32")return e instanceof Int32Array?e:new Int32Array(e);if(t==="bool"||t==="string")return Uint8Array.from(new Int32Array(e));throw new Error(`Unknown dtype ${t}`)}function He(e,t){const n=Vt(e,t);for(let s=0;s<n.length;s++)n[s]=1;return n}function Vt(e,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool")return new Uint8Array(e);throw new Error(`Unknown data type ${t}`)}function is(e,t){const n=e.reduce((s,r)=>s*r,1);if(t==null||t==="float32")return dt(e,new Float32Array(n));if(t==="int32")return dt(e,new Int32Array(n));if(t==="bool")return dt(e,new Uint8Array(n));throw new Error(`Unknown data type ${t}`)}function It(e){e.forEach(t=>{b(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${e}].`)})}function cs(e,t,n){if(t===0)return 0;if(t===1)return e[0];let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=n[r]*e[r];return s}function ls(e,t,n){if(t===0)return[];if(t===1)return[e];const s=new Array(t);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(e/n[r]),e-=s[r]*n[r];return s[s.length-1]=e,s}function qt(e){return e&&e.then&&typeof e.then=="function"}const xe="tfjsflags";class us{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=fs,this.populateURLFlags()}setPlatform(t,n){this.platform!=null&&(S().getBool("IS_TEST")||S().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=t,this.platform=n}registerFlag(t,n,s){if(this.flagRegistry[t]={evaluationFn:n,setHook:s},this.urlFlags[t]!=null){const r=this.urlFlags[t];S().getBool("IS_TEST")||S().getBool("PROD")||console.warn(`Setting feature override from URL ${t}: ${r}.`),this.set(t,r)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];const n=this.evaluateFlag(t);if(qt(n))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=n,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getString(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,n){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=n,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(n)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const t=this.getQueryParams(this.global.location.search);xe in t&&t[xe].split(",").forEach(s=>{const[r,o]=s.split(":");this.urlFlags[r]=ds(r,o)})}}function fs(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...s)=>(hs(t,s[0],s[1]),s.join("="))),t}function hs(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}function ds(e,t){const n=t.toLowerCase();return n==="true"||n==="false"?n==="true":`${+n}`===n?+n:t}function S(){return Xe}let Xe=null;function gs(e){Xe=e}let te;function Je(){if(te==null){let e;if(typeof window<"u")e=window;else if(typeof global<"u")e=global;else if(typeof process<"u")e=process;else if(typeof self<"u")e=self;else throw new Error("Could not find a global object");te=e}return te}function ms(){const e=Je();return e._tfGlobals==null&&(e._tfGlobals=new Map),e._tfGlobals}function Se(e,t){const n=ms();if(n.has(e))return n.get(e);{const s=t();return n.set(e,s),n.get(e)}}const ps="Abs",na="Acos",sa="Acosh",Ye="Add",ra="AddN",oa="All",aa="Any",ia="ArgMax",ca="ArgMin",la="Asin",ua="Asinh",fa="Atan",ha="Atanh",da="Atan2",ga="AvgPool",ma="AvgPoolGrad",pa="AvgPool3D",ya="AvgPool3DGrad",ba="BatchMatMul",wa="BatchToSpaceND",Sa="Bincount",ka="BitwiseAnd",Ia="BroadcastTo",Aa="BroadcastArgs",Ze="Cast",Ta="Ceil",Ea="ClipByValue",ys="Complex",bs="ComplexAbs",xa="Concat",Ma="Conv2D",va="Conv2DBackpropFilter",$a="Conv2DBackpropInput",Ba="Conv3D",Da="Conv3DBackpropFilterV2",Ra="Conv3DBackpropInputV2",Fa="Cos",Na="Cosh",Ca="Cumprod",Pa="Cumsum",_a="CropAndResize",La="DenseBincount",Oa="DepthToSpace",Ua="DepthwiseConv2dNative",Ga="DepthwiseConv2dNativeBackpropFilter",za="DepthwiseConv2dNativeBackpropInput",Wa="Diag",ja="Dilation2D",Va="Dilation2DBackpropInput",qa="Dilation2DBackpropFilter",Ka="Draw",ws="RealDiv",Ha="Einsum",Ss="Elu",Xa="EluGrad",Ja="Erf",Ya="Equal",Za="Exp",Qa="ExpandDims",ti="Expm1",ei="FFT",ks="Fill",ni="FlipLeftRight",si="Floor",Is="FloorDiv",ri="FusedBatchNorm",oi="GatherV2",ai="GatherNd",ii="Greater",ci="GreaterEqual",Qe="Identity",li="IFFT",ui="Imag",fi="IsFinite",hi="IsInf",di="IsNan",As="LeakyRelu",gi="Less",mi="LessEqual",pi="LinSpace",yi="Log",bi="Log1p",wi="LogicalAnd",Si="LogicalNot",ki="LogicalOr",Ii="LogicalXor",Ai="LogSoftmax",Ti="LowerBound",Ei="LRN",xi="LRNGrad",Mi="MatrixBandPart",vi="Max",Ts="Maximum",$i="MaxPool",Bi="MaxPoolGrad",Di="MaxPool3D",Ri="MaxPool3DGrad",Fi="MaxPoolWithArgmax",Ni="Mean",Ci="Min",Pi="Minimum",_i="MirrorPad",Li="Mod",Oi="Multinomial",Es="Multiply",Ui="Neg",Gi="NotEqual",zi="NonMaxSuppressionV3",Wi="NonMaxSuppressionV4",ji="NonMaxSuppressionV5",Vi="OnesLike",qi="OneHot",Ki="Pack",Hi="PadV2",Xi="Pool",xs="Pow",Ms="Prelu",Ji="Prod",Yi="RaggedGather",Zi="RaggedRange",Qi="RaggedTensorToTensor",tc="Range",ec="Real",nc="Reciprocal",vs="Relu",$s="Reshape",sc="ResizeNearestNeighbor",rc="ResizeNearestNeighborGrad",oc="ResizeBilinear",ac="ResizeBilinearGrad",Bs="Relu6",ic="Reverse",cc="Round",lc="Rsqrt",uc="ScatterNd",fc="TensorScatterUpdate",hc="SearchSorted",dc="Select",gc="Selu",mc="Slice",pc="Sin",yc="Sinh",bc="Sign",Ds="Sigmoid",wc="Softplus",Rs="Sqrt",Fs="Sum",Sc="SpaceToBatchND",kc="SplitV",Ic="Softmax",Ac="SparseFillEmptyRows",Tc="SparseReshape",Ec="SparseSegmentMean",xc="SparseSegmentSum",Mc="SparseToDense",vc="SquaredDifference",$c="Square",Bc="StaticRegexReplace",Dc="StridedSlice",Rc="StringNGrams",Fc="StringSplit",Nc="StringToHashBucketFast",Ns="Sub",Cc="Tan",Pc="Tanh",Cs="Tile",_c="TopK",Lc="Transform",Oc="Transpose",Uc="Unique",Gc="Unpack",zc="UnsortedSegmentSum",Wc="UpperBound",Ps="ZerosLike",_s="Step",jc="FromPixels",Vc="RotateWithOffset",qc="_FusedMatMul",Kc="FusedConv2D",Hc="FusedDepthwiseConv2D";function tt(...e){S().getBool("IS_TEST")||S().getBool("PROD")||console.warn(...e)}function Xc(...e){S().getBool("IS_TEST")||S().getBool("PROD")||console.log(...e)}const yt=Se("kernelRegistry",()=>new Map),Mt=Se("gradRegistry",()=>new Map);function Me(e,t){const n=ke(e,t);return yt.get(n)}function ve(e){return Mt.get(e)}function oe(e){const t=yt.entries(),n=[];for(;;){const{done:s,value:r}=t.next();if(s)break;const[o,a]=r,[i]=o.split("_");i===e&&n.push(a)}return n}function Ls(e){const{kernelName:t,backendName:n}=e,s=ke(t,n);yt.has(s)&&tt(`The kernel '${t}' for backend '${n}' is already registered`),yt.set(s,e)}function Jc(e){const{kernelName:t}=e;Mt.has(t)&&S().getBool("DEBUG")&&tt(`Overriding the gradient for '${t}'`),Mt.set(t,e)}function Yc(e,t){const n=ke(e,t);if(!yt.has(n))throw new Error(`The kernel '${e}' for backend '${t}' is not registered`);yt.delete(n)}function Zc(e){if(!Mt.has(e))throw new Error(`The gradient '${e}' for backend is not registered`);Mt.delete(e)}function Qc(e,t){oe(e).forEach(s=>{const r=Object.assign({},s,{backendName:t});Ls(r)})}function ke(e,t){return`${t}_${e}`}function tn(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}const et=_n||Ln;function Nt(e){return et.fromString(e,!0,16)}const en=Nt("c3a5c85c97cb3127"),Q=Nt("b492b66fbe98f273"),N=Nt("9ae16a3b2f90404f");function ae(e){return e.xor(e.shru(47))}function nn(e,t,n){const s=e.slice(t,t+n);return et.fromBytes(Array.from(s),!0,!0)}function T(e,t){return nn(e,t,8)}function $e(e,t){return nn(e,t,4)}function $(e,t){return t===0?e:e.shru(t).or(e.shl(64-t))}function X(e,t,n=Nt("9ddfea08eb382d69")){let s=e.xor(t).mul(n);s=s.xor(s.shru(47));let r=t.xor(s).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function Os(e,t,n,s,r,o){r=r.add(e),o=$(o.add(r).add(s),21);const a=r;return r=r.add(t),r=r.add(n),o=o.add($(r,44)),[r.add(s),o.add(a)]}function Ct(e,t,n,s){return Os(T(e,t),T(e,t+8),T(e,t+16),T(e,t+24),n,s)}function Us(e,t=e.length){if(t>=8){const n=N.add(t*2),s=T(e,0).add(N),r=T(e,t-8),o=$(r,37).mul(n).add(s),a=$(s,25).add(r).mul(n);return X(o,a,n)}if(t>=4){const n=N.add(t*2),s=$e(e,0);return X(s.shl(3).add(t),$e(e,t-4),n)}if(t>0){const n=e[0],s=e[t>>1],r=e[t-1],o=n+(s<<8),a=t+(r<<2);return ae(N.mul(o).xor(en.mul(a))).mul(N)}return N}function Gs(e,t=e.length){const n=N.add(t*2),s=T(e,0).mul(Q),r=T(e,8),o=T(e,t-8).mul(n),a=T(e,t-16).mul(N);return X($(s.add(r),43).add($(o,30)).add(a),s.add($(r.add(N),18)).add(o),n)}function zs(e,t=e.length){const n=N.add(t*2),s=T(e,0).mul(N),r=T(e,8),o=T(e,t-8).mul(n),a=T(e,t-16).mul(N),i=$(s.add(r),43).add($(o,30)).add(a),c=X(i,s.add($(r.add(N),18)).add(o),n),l=T(e,16).mul(n),f=T(e,24),u=i.add(T(e,t-32)).mul(n),h=c.add(T(e,t-24)).mul(n);return X($(l.add(f),43).add($(u,30)).add(h),l.add($(f.add(s),18)).add(u),n)}function Ws(e,t=e.length){const n=et.fromNumber(81,!0);if(t<=32)return t<=16?Us(e,t):Gs(e,t);if(t<=64)return zs(e,t);let s=n,r=n.mul(Q).add(113),o=ae(r.mul(N).add(113)).mul(N),a=[et.UZERO,et.UZERO],i=[et.UZERO,et.UZERO];s=s.mul(N).add(T(e,0));let c=0;const l=(t-1>>6)*64,f=l+(t-1&63)-63;do s=$(s.add(r).add(a[0]).add(T(e,c+8)),37).mul(Q),r=$(r.add(a[1]).add(T(e,c+48)),42).mul(Q),s=s.xor(i[1]),r=r.add(a[0]).add(T(e,c+40)),o=$(o.add(i[0]),33).mul(Q),a=Ct(e,c,a[1].mul(Q),s.add(i[0])),i=Ct(e,c+32,o.add(i[1]),r.add(T(e,c+16))),[o,s]=[s,o],c+=64;while(c!==l);const u=Q.add(o.and(255).shl(1));return c=f,i[0]=i[0].add(t-1&63),a[0]=a[0].add(i[0]),i[0]=i[0].add(a[0]),s=$(s.add(r).add(a[0]).add(T(e,c+8)),37).mul(u),r=$(r.add(a[1]).add(T(e,c+48)),42).mul(u),s=s.xor(i[1].mul(9)),r=r.add(a[0].mul(9).add(T(e,c+40))),o=$(o.add(i[0]),33).mul(u),a=Ct(e,c,a[1].mul(u),s.add(i[0])),i=Ct(e,c+32,o.add(i[1]),r.add(T(e,c+16))),[o,s]=[s,o],X(X(a[0],i[0],u).add(ae(r).mul(en)).add(o),X(a[1],i[1],u).add(s),u)}function js(e,t){return t==="string"?Ie(e):Kt([e],t)}function Vs(e,t){return e instanceof Float32Array&&t==="float32"||e instanceof Int32Array&&t==="int32"||e instanceof Uint8Array&&t==="bool"}function Kt(e,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=bt(e)),S().getBool("DEBUG")&&ze(e,t),Vs(e,t))return e;if(t==null||t==="float32"||t==="complex64")return new Float32Array(e);if(t==="int32")return new Int32Array(e);if(t==="bool"){const n=new Uint8Array(e.length);for(let s=0;s<n.length;++s)Math.round(e[s])!==0&&(n[s]=1);return n}else throw new Error(`Unknown data type ${t}`)}function vt(){return S().platform.now()}function qs(e,t){return S().platform.fetch(e,t)}function Ie(e,t="utf-8"){return t=t||"utf-8",S().platform.encode(e,t)}function ie(e,t="utf-8"){return t=t||"utf-8",S().platform.decode(e,t)}function U(e){return S().platform.isTypedArray!=null?S().platform.isTypedArray(e):tn(e)}function bt(e,t=[],n=!1){if(t==null&&(t=[]),typeof e=="boolean"||typeof e=="number"||typeof e=="string"||qt(e)||e==null||U(e)&&n)t.push(e);else if(Array.isArray(e)||U(e))for(let s=0;s<e.length;++s)bt(e[s],t,n);else{let s=-1;for(const r of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(r)&&(s=Math.max(s,Number(r)));for(let r=0;r<=s;r++)bt(e[r],t,n)}return t}const tl=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:Wt,arraysEqualWithNull:Jn,assert:b,assertNonNegativeIntegerDimensions:It,assertNonNull:Hn,assertShapesMatch:Dt,bytesFromStringArray:je,bytesPerElement:Ut,checkConversionForErrors:ze,clamp:Wn,computeStrides:Ft,convertBackendValuesAndArrayBuffer:as,createScalarValue:js,createShuffledIndices:Qn,decodeString:ie,distSquared:Kn,encodeString:Ie,fetch:qs,fingerPrint64:Ws,flatten:bt,getArrayFromDType:we,getTypedArrayFromDType:ss,hasEncodingLoss:rs,hexToLong:Nt,indexToLoc:ls,inferDtype:Rt,inferFromImplicitShape:es,isBoolean:Ve,isFunction:J,isInt:Ot,isNumber:qe,isPromise:qt,isScalarShape:Xn,isString:jt,isTypedArray:U,isValidDtype:We,locToIndex:cs,makeOnesTypedArray:He,makeZerosNestedTypedArray:is,makeZerosTypedArray:Vt,nearestDivisor:os,nearestLargerEven:jn,now:vt,parseAxisParam:Ge,randUniform:qn,repeatedTry:ts,rightPad:xt,shuffle:Ue,shuffleCombo:zn,sizeFromShape:C,sizeToSquarishShape:Zn,squeezeShape:ns,sum:Vn,swap:Lt,tanh:Yn,toNestedArray:dt,toTypedArray:Kt},Symbol.toStringTag,{value:"Module"}));class Ks{constructor(t,n){this.backendTimer=t,this.logger=n,n==null&&(this.logger=new Xs)}profileKernel(t,n,s){let r;const o=()=>{r=s()};let a;const i=vt();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(o);else{o();for(const l of r)l.dataSync();a=Promise.resolve({kernelMs:vt()-i})}if(S().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<r.length;l++){const f=r[l];f.data().then(u=>{Hs(u,f.dtype,t)})}return{kernelName:t,outputs:r,inputs:n,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(t){const{kernelName:n,outputs:s,timeMs:r,inputs:o,extraInfo:a}=t;s.forEach(i=>{Promise.all([i.data(),r,a]).then(c=>{this.logger.logKernelProfile(n,i,c[0],c[1],o,c[2])})})}}function Hs(e,t,n){if(t!=="float32")return!1;for(let s=0;s<e.length;s++){const r=e[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${n}'`),!0}return!1}class Xs{logKernelProfile(t,n,s,r,o,a){const i=typeof r=="number"?xt(`${r}ms`,9):r.error,c=xt(t,25),l=n.rank,f=n.size,u=xt(n.shape.toString(),14);let h="";for(const m in o){const p=o[m];if(p!=null){const d=p.shape||n.shape,y=d.length;h+=`${m}: ${y}D ${y>0?d:""} `}}console.log(`%c${c}	%c${i}	%c${l}D ${u}	%c${f}	%c${h}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function Js(e,t,n){const s={},r={};for(let c=0;c<t.length;c++)s[t[c].id]=!0;for(let c=0;c<e.length;c++){const l=e[c],f=l.inputs;for(const u in f){const h=f[u];let m=!1;for(let p=0;p<t.length;p++)if(s[h.id]){l.outputs.forEach(d=>s[d.id]=!0),m=!0,r[l.id]=!0;break}if(m)break}}const o={};o[n.id]=!0;const a={};for(let c=e.length-1;c>=0;c--){const l=e[c],f=l.inputs;for(let u=0;u<l.outputs.length;u++)if(o[l.outputs[u].id]){for(const h in f)o[f[h].id]=!0,a[l.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const l=e[c];if(r[l.id]&&a[l.id]){const f={};for(const h in l.inputs){const m=l.inputs[h];s[m.id]&&(f[h]=m)}const u=Object.assign({},l);u.inputs=f,u.outputs=l.outputs,i.push(u)}}return i}function Ys(e,t,n,s){for(let r=t.length-1;r>=0;r--){const o=t[r],a=[];if(o.outputs.forEach(c=>{const l=e[c.id];l!=null?a.push(l):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);const i=o.gradient(a);for(const c in o.inputs){if(!(c in i))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(i)}.`);const l=n(()=>i[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);const f=o.inputs[c];if(!Wt(l.shape,f.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${f.shape}'`);if(e[f.id]==null)e[f.id]=l;else{const u=e[f.id];e[f.id]=s(u,l),u.dispose()}}}}const Be=20,At=3,ee=7;function Zs(e,t,n,s){const r=Ft(t),o=Qs(e,t,n,r),a=t.length,i=Pt(e,t,n,r,o),c=["Tensor"];return s&&(c.push(`  dtype: ${n}`),c.push(`  rank: ${a}`),c.push(`  shape: [${t}]`),c.push("  values:")),c.push(i.map(l=>"    "+l).join(`
`)),c.join(`
`)}function Qs(e,t,n,s){const r=C(t),o=s[s.length-1],a=new Array(o).fill(0),i=t.length,c=n==="complex64"?Et(e):e;if(i>1)for(let l=0;l<r/o;l++){const f=l*o;for(let u=0;u<o;u++)a[u]=Math.max(a[u],Tt(c[f+u],0,n).length)}return a}function Tt(e,t,n){let s;return Array.isArray(e)?s=`${parseFloat(e[0].toFixed(ee))} + ${parseFloat(e[1].toFixed(ee))}j`:jt(e)?s=`'${e}'`:n==="bool"?s=sn(e):s=parseFloat(e.toFixed(ee)).toString(),xt(s,t)}function sn(e){return e===0?"false":"true"}function Pt(e,t,n,s,r,o=!0){const a=n==="complex64"?2:1,i=t[0],c=t.length;if(c===0){if(n==="complex64"){const d=Et(e);return[Tt(d[0],0,n)]}return n==="bool"?[sn(e[0])]:[e[0].toString()]}if(c===1){if(i>Be){const y=At*a;let w=Array.from(e.slice(0,y)),x=Array.from(e.slice((i-At)*a,i*a));return n==="complex64"&&(w=Et(w),x=Et(x)),["["+w.map((v,D)=>Tt(v,r[D],n)).join(", ")+", ..., "+x.map((v,D)=>Tt(v,r[i-At+D],n)).join(", ")+"]"]}return["["+(n==="complex64"?Et(e):Array.from(e)).map((y,w)=>Tt(y,r[w],n)).join(", ")+"]"]}const l=t.slice(1),f=s.slice(1),u=s[0]*a,h=[];if(i>Be){for(let d=0;d<At;d++){const y=d*u,w=y+u;h.push(...Pt(e.slice(y,w),l,n,f,r,!1))}h.push("...");for(let d=i-At;d<i;d++){const y=d*u,w=y+u;h.push(...Pt(e.slice(y,w),l,n,f,r,d===i-1))}}else for(let d=0;d<i;d++){const y=d*u,w=y+u;h.push(...Pt(e.slice(y,w),l,n,f,r,d===i-1))}const m=c===2?",":"";h[0]="["+(i>0?h[0]+m:"");for(let d=1;d<h.length-1;d++)h[d]=" "+h[d]+m;let p=`,
`;for(let d=2;d<c;d++)p+=`
`;return h[h.length-1]=" "+h[h.length-1]+"]"+(o?"":p),h}function Et(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class tr{constructor(t,n,s){if(this.dtype=n,this.shape=t.slice(),this.size=C(t),s!=null){const r=s.length;b(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||we(n,this.size),this.strides=Ft(t)}set(t,...n){n.length===0&&(n=[0]),b(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const s=this.locToIndex(n);this.values[s]=t}get(...t){t.length===0&&(t=[0]);let n=0;for(const r of t){if(r<0||r>=this.shape[n]){const o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}n++}let s=t[t.length-1];for(let r=0;r<t.length-1;++r)s+=this.strides[r]*t[r];return this.values[s]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return n}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];const n=new Array(this.shape.length);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(t/this.strides[s]),t-=n[s]*this.strides[s];return n[n.length-1]=t,n}get rank(){return this.shape.length}toTensor(){return z().makeTensor(this.values,this.shape,this.dtype)}}let z=null,ft=null;function er(e){z=e}function nr(e){ft=e}class P{constructor(t,n,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=n||"float32",this.size=C(t),this.strides=Ft(t),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const t=await this.data();return ft.buffer(this.shape,this.dtype,t)}bufferSync(){return ft.buffer(this.shape,this.dtype,this.dataSync())}async array(){const t=await this.data();return dt(this.shape,t,this.dtype==="complex64")}arraySync(){return dt(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const t=z().read(this.dataId);if(this.dtype==="string"){const n=await t;try{return n.map(s=>ie(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataToGPU(t){return this.throwIfDisposed(),z().readToGPU(this.dataId,t)}dataSync(){this.throwIfDisposed();const t=z().readSync(this.dataId);if(this.dtype==="string")try{return t.map(n=>ie(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();const t=await z().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),z().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return ft.print(this,t)}clone(){return this.throwIfDisposed(),ft.clone(this)}toString(t=!1){const n=this.dataSync();return Zs(n,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),ft.cast(this,t)}variable(t=!0,n,s){return this.throwIfDisposed(),z().makeVariable(this,t,n,s)}}Object.defineProperty(P,Symbol.hasInstance,{value:e=>!!e&&e.data!=null&&e.dataSync!=null&&e.throwIfDisposed!=null});function rn(){return Se("Tensor",()=>P)}rn();class Gt extends P{constructor(t,n,s,r){super(t.shape,t.dtype,t.dataId,r),this.trainable=n,this.name=s}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Wt(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);z().disposeTensor(this),this.dataId=t.dataId,z().incRef(this,null)}dispose(){z().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Gt,Symbol.hasInstance,{value:e=>e instanceof P&&e.assign!=null&&e.assign instanceof Function});var De;(function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"})(De||(De={}));var ce;(function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"})(ce||(ce={}));var le;(function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"})(le||(le={}));var ue;(function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"})(ue||(ue={}));var fe;(function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"})(fe||(fe={}));const sr={float32:ue,int32:ce,bool:le,complex64:fe};function on(e,t){if(e==="string"||t==="string"){if(e==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${e} with ${t}`)}return sr[e][t]}function el(e){return on(e,"int32")}function an(e){return e!=null&&typeof e=="object"&&"texture"in e&&e.texture instanceof WebGLTexture}function cn(e){return typeof GPUBuffer<"u"&&e!=null&&typeof e=="object"&&"buffer"in e&&e.buffer instanceof GPUBuffer}function Z(e,t){if(e.dtype===t.dtype)return[e,t];const n=on(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function rr(e,t){b(e.dtype===t.dtype,()=>`The dtypes of the first(${e.dtype}) and second(${t.dtype}) input must match`)}function or(e,t){return t.some(n=>n.id===e.id)}function Ae(e){const t=[];return ln(e,t,new Set),t}function ln(e,t,n){if(e==null)return;if(e instanceof P){t.push(e);return}if(!ar(e))return;const s=e;for(const r in s){const o=s[r];n.has(o)||(n.add(o),ln(o,t,n))}}function ar(e){return Array.isArray(e)||typeof e=="object"}const nl=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:rr,getTensorsInContainer:Ae,isTensorInList:or,makeTypesMatch:Z},Symbol.toStringTag,{value:"Module"}));function ne(e){return e.kernelName!=null}class Re{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(const t in this.registeredVariables)this.registeredVariables[t].dispose()}}class wt{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new Re}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:t,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){const{asyncInit:n}=this.initializeBackend(t);if(n)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,n,s=1){return t in this.registryFactory?(tt(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:n,priority:s},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;const{success:n,asyncInit:s}=this.initializeBackend(t);if(!(s?await n:n))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new Ks(this.backendInstance),!0}setupRegisteredKernels(){oe(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){oe(t).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[t])})}initializeBackend(t){const n=this.registryFactory[t];if(n==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{const s=n.factory();if(s&&!(s instanceof Gn)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,o=s.then(a=>r<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,tt(`Initialization of backend ${t} failed`),tt(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[t]=s,{success:!0,asyncInit:!1}}catch(s){return tt(`Initialization of backend ${t} failed`),tt(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,n)=>this.registryFactory[n].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){const t=this.getSortedBackends();for(let n=0;n<t.length;n++){const s=t[n],{success:r,asyncInit:o}=this.initializeBackend(s);if(o||r)return{name:s,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,n){const s=this.state.tensorInfo.get(n),r=s.backend,o=this.readSync(n),a=r.refCount(n);r.disposeData(n,!0),s.backend=t,t.move(n,o,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,n){let s=null;if(n==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");n=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=t}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=n(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(t,n,s){t();try{const r=s();return n(),r}catch(r){throw n(),r}}nextTensorId(){return wt.nextTensorId++}nextVariableId(){return wt.nextVariableId++}clone(t){const n=g.runKernel(Qe,{x:t}),s={x:t},r=a=>({x:()=>{const i="float32",c={x:a},l={dtype:i};return g.runKernel(Ze,c,l)}}),o=[];return this.addTapeNode(this.state.activeScope.name,s,[n],r,o,{}),n}runKernel(t,n,s){if(this.backendName==null&&this.backend,!(Me(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:n,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,n,s){const r=this.backend.numDataIds();let o=0;s.forEach(c=>{o+=c.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],i=r-n-o-a;if(i>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${i} data ids) after running '${t}'`)}runKernelFunc(t){let n,s=[];const r=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let i;this.backendName==null&&this.backend;let c;const l=ne(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ne(t)){const{kernelName:p,inputs:d,attrs:y}=t;this.backendName==null&&this.backend;const w=Me(p,this.backendName);b(w!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),i=()=>{const x=this.backend.numDataIds();c=w.kernelFunc({inputs:d,attrs:y,backend:this.backend});const v=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,x,v);const D=v.map(R=>R.rank!=null?R:this.makeTensorFromTensorInfo(R));if(r){const R=this.getTensorsForGradient(p,d,D);s=this.saveTensorsForBackwardMode(R)}return D}}else{const{forwardFunc:p}=t,d=y=>{r&&(s=y.map(w=>this.keep(this.clone(w))))};i=()=>{const y=this.backend.numDataIds();c=this.tidy(()=>p(this.backend,d));const w=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,y,w),w}}const{inputs:f,attrs:u}=t,h=ne(t)?null:t.backwardsFunc;let m;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=i():(m=this.profiler.profileKernel(l,f,()=>i()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(m),n=m.outputs)}),r&&this.addTapeNode(l,f,n,h,s,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(p=>f[p]!=null?f[p].shape:null),outputShapes:n.map(p=>p.shape),kernelTimeMs:m.timeMs,extraInfo:m.extraInfo}),Array.isArray(c)?n:n[0]}saveTensorsForBackwardMode(t){return t.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(t,n,s){const r=ve(t);if(r!=null){const o=r.inputsToSave||[],a=r.outputsToSave||[];let i;r.saveAllInputs?(b(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),i=Object.keys(n).map(l=>n[l])):i=o.map(l=>n[l]);const c=s.filter((l,f)=>a[f]);return i.concat(c)}return[]}makeTensor(t,n,s,r){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let o=t;s==="string"&&jt(t[0])&&(o=t.map(c=>Ie(c)));const a=r.write(o,n,s),i=new P(n,s,a,this.nextTensorId());if(this.trackTensor(i,r),s==="string"){const c=this.state.tensorInfo.get(a),l=je(o);this.state.numBytes+=l-c.bytes,c.bytes=l}return i}makeTensorFromDataId(t,n,s,r){s=s||"float32";const o={dataId:t,shape:n,dtype:s};return this.makeTensorFromTensorInfo(o,r)}makeTensorFromTensorInfo(t,n){const{dataId:s,shape:r,dtype:o}=t,a=new P(r,o,s,this.nextTensorId());return this.trackTensor(a,n),a}makeVariable(t,n=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==t.dtype&&(t=t.cast(r));const o=new Gt(t,n,s,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}trackTensor(t,n){this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*Ut(t.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(t.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(t.dataId,{backend:n||this.backend,dtype:t.dtype,shape:t.shape,bytes:s})),t instanceof Gt||this.track(t)}incRef(t,n){this.trackTensor(t,n),this.backend.incRef(t.dataId)}removeDataId(t,n){this.state.tensorInfo.has(t)&&this.state.tensorInfo.get(t).backend===n&&(this.state.tensorInfo.delete(t),this.state.numDataBuffers--)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;const n=this.state.tensorInfo.get(t.dataId);if(this.state.numTensors--,t.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),t.dtype!=="complex64"&&t.dtype!=="string"){const s=t.size*Ut(t.dtype);this.state.numBytes-=s}n.backend.disposeData(t.dataId)&&this.removeDataId(t.dataId,n.backend)}disposeVariables(){for(const t in this.state.registeredVariables){const n=this.state.registeredVariables[t];this.disposeVariable(n)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){const t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;const n=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,n,s,r,o,a){const i={id:this.state.nextTapeNodeId++,kernelName:t,inputs:n,outputs:s,saved:o},c=ve(t);c!=null&&(r=c.gradFunc),r!=null&&(i.gradient=l=>(l=l.map((f,u)=>{if(f==null){const h=s[u],m=Vt(h.size,h.dtype);return this.makeTensor(m,h.shape,h.dtype)}return f}),r(l.length>1?l:l[0],o,a))),this.state.activeTape.push(i)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(n.name=t),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(t){const n=Ae(t),s=new Set(n.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){const a=this.state.activeScope.track[o];!a.kept&&!s.has(a.id)&&a.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(o=>{!o.kept&&o.scopeId===r.id&&this.track(o)})}gradients(t,n,s,r=!1){if(b(n.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));b(o instanceof P,()=>"The result y returned by f() must be a tensor.");const a=Js(this.state.activeTape,n,o);if(!r&&a.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const i={};i[o.id]=s??ir(o.shape),Ys(i,a,l=>this.tidy(l),cr);const c=n.map(l=>i[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const f of l.saved)f.dispose()}),this.state.activeTape=null),{value:o,grads:c}})}customGrad(t){return b(J(t),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{b(n.every(i=>i instanceof P),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};n.forEach((i,c)=>{r[c]=i});const o=(i,c)=>(s=t(...n,c),b(s.value instanceof P,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),b(J(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(i,c)=>{const l=s.gradFunc(i,c),f=Array.isArray(l)?l:[l];b(f.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),b(f.every(h=>h instanceof P),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const u={};return f.forEach((h,m)=>{u[m]=()=>h}),u};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:r})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}readToGPU(t,n){return this.state.tensorInfo.get(t).backend.readToGPU(t,n)}async time(t){const n=vt(),s=await this.backend.time(t);return s.wallMs=vt()-n,s}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new Re;for(const t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}wt.nextTensorId=0;wt.nextVariableId=0;function ir(e){const t=He(C(e),"float32");return g.makeTensor(t,e,"float32")}function un(){const e=Je();if(e._tfengine==null){const t=new us(e);e._tfengine=new wt(t)}return gs(e._tfengine.ENV),er(()=>e._tfengine),e._tfengine}const g=un();function cr(e,t){const n={a:e,b:t};return g.runKernel(Ye,n)}function lr(){return typeof navigator<"u"&&navigator!=null}let he;function ur(e){he=e}function fr(e){if(he!==void 0)return he;if(e||lr()){if(e||(e=navigator),e.product==="ReactNative")return!0;const t=e.userAgent||e.vendor||(typeof window<"u"?window.opera:"");if(!t){const n=e;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function fn(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const sl=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:fn,isMobile:fr,mockIsMobile:ur},Symbol.toStringTag,{value:"Module"}));const _=S();_.registerFlag("DEBUG",()=>!1,e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});_.registerFlag("IS_BROWSER",()=>fn());_.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");_.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));_.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));_.registerFlag("PROD",()=>!1);_.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>_.getBool("DEBUG"));_.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);_.registerFlag("IS_TEST",()=>!1);_.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>_.getBool("DEBUG"));_.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);_.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);_.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function hn(e,t){let n=e;if(U(e))return t==="string"?[]:[e.length];if(an(e)){const r=e.channels||"RGBA";return[e.height,e.width*r.length]}else if(cn(e))return[e.buffer.size/(t==null?4:Ut(t))];if(!Array.isArray(e))return[];const s=[];for(;Array.isArray(n)||U(n)&&t!=="string";)s.push(n.length),n=n[0];return Array.isArray(e)&&S().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&dn(e,s,[]),s}function dn(e,t,n){if(n=n||[],!Array.isArray(e)&&!U(e)){b(t.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}b(t.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${e.length} elements`),b(e.length===t[0],()=>`Element arr[${n.join("][")}] should have ${t[0]} elements, but has ${e.length} elements`);const s=t.slice(1);for(let r=0;r<e.length;++r)dn(e[r],s,n.concat(r))}function Fe(e,t,n,s){if(e!=="string_or_numeric"){if(e==null)throw new Error("Expected dtype cannot be null.");if(e!=="numeric"&&e!==t||e==="numeric"&&t==="string")throw new Error(`Argument '${n}' passed to '${s}' must be ${e} tensor, but got ${t} tensor`)}}function k(e,t,n,s="numeric"){if(e instanceof rn())return Fe(s,e.dtype,t,n),e;let r=Rt(e);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),Fe(s,r,t,n),e==null||!U(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string"){const c=e==null?"null":e.constructor.name;throw new Error(`Argument '${t}' passed to '${n}' must be a Tensor or TensorLike, but got '${c}'`)}const o=hn(e,r);!U(e)&&!Array.isArray(e)&&(e=[e]);const i=r!=="string"?Kt(e,r):bt(e,[],!0);return g.makeTensor(i,o,r)}function hr(e,t,n,s="numeric"){if(!Array.isArray(e))throw new Error(`Argument ${t} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return e.map((o,a)=>k(o,`${t}[${a}]`,n,s))}const dr="__op";function E(e){const t=Object.keys(e);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let n=t[0];const s=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+dr;const r=(...o)=>{g.startScope(n);try{const a=s(...o);return qt(a)&&console.error("Cannot return a Promise inside of tidy."),g.endScope(a),a}catch(a){throw g.endScope(null),a}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}function gr(e,t){const n=k(e,"real","complex"),s=k(t,"imag","complex");Dt(n.shape,s.shape,`real and imag shapes, ${n.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:n,imag:s};return g.runKernel(ys,r)}const gn=E({complex_:gr});function mn(e,t,n,s){if(s==null)s=Rt(e);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(cn(e)||an(e)){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return g.backend.createTensorFromGPUData(e,t||n,s)}if(!U(e)&&!Array.isArray(e)&&typeof e!="number"&&typeof e!="boolean"&&typeof e!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){It(t);const r=C(t),o=C(n);b(r===o,()=>`Based on the provided shape, [${t}], the tensor should have ${r} values but has ${o}`);for(let a=0;a<n.length;++a){const i=n[a],c=a===n.length-1?i!==C(t.slice(a)):!0;b(n[a]===t[a]||!c,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${t}). `)}}return!U(e)&&!Array.isArray(e)&&(e=[e]),t=t||n,e=s!=="string"?Kt(e,s):bt(e,[],!0),g.makeTensor(e,t,s)}function se(e,t,n){const s=hn(e,n);return mn(e,t,s,n)}const St={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};class it{static join(t){return new it(t).slice()}constructor(t){if(this.shards=[],this.previousShardIndex=0,t==null||(t instanceof Array||(t=[t]),t=t.map(s=>U(s)?s.buffer:s),t.length===0))return;this.bufferUniformSize=t[0].byteLength;let n=0;for(let s=0;s<t.length;s++){const r=t[s];s!==t.length-1&&r.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const o=n+r.byteLength;this.shards.push({buffer:r,start:n,end:o}),n=o}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(t=0,n=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(t=isNaN(Number(t))?0:t,n=isNaN(Number(n))?0:n,t=Math.max(0,t),n=Math.min(this.byteLength,n),n<=t)return new ArrayBuffer(0);const s=this.findShardForByte(t);if(s===-1)throw new Error(`Could not find start shard for byte ${t}`);const r=n-t,o=new ArrayBuffer(r),a=new Uint8Array(o);let i=0;for(let c=s;c<this.shards.length;c++){const l=this.shards[c],u=t+i-l.start,h=i,p=Math.min(n,l.end)-l.start,d=new Uint8Array(l.buffer,u,p-u);if(a.set(d,h),i+=d.length,n<l.end)break}return o}findShardForByte(t){if(this.shards.length===0||t<0||t>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(t/this.bufferUniformSize),this.previousShardIndex;function n(r){return t<r.start?-1:t>=r.end?1:0}if(n(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const s=mr(this.shards,n);return s===-1?-1:(this.previousShardIndex=s,this.previousShardIndex)}}function mr(e,t){let n=0,s=e.length;for(;n<=s;){const r=Math.floor((s-n)/2)+n,o=t(e[r]);if(o===0)return r;o<0?s=r:n=r+1}return-1}function rl(){S().set("PROD",!0)}function ol(){S().set("DEBUG",!0)}function al(){S().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function il(e){S().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function cl(){g.disposeVariables()}function ll(){return g}function ul(){return g.memory()}function fl(e){return g.profile(e)}function B(e,t){return g.tidy(e,t)}function O(e){Ae(e).forEach(n=>n.dispose())}function pr(e){return g.keep(e)}function hl(e){return g.time(e)}function dl(e){return g.setBackend(e)}function gl(){return g.ready()}function yr(){return g.backendName}function ml(e){g.removeBackend(e)}function pl(e){return g.findBackend(e)}function yl(e){return g.findBackendFactory(e)}function bl(e,t,n=1){return g.registerBackend(e,t,n)}function br(){return g.backend}function wl(e,t){S().setPlatform(e,t)}const Y=4;async function Sl(e,t){const n=[],s=[],r=Array.isArray(e)?e.map(a=>a.name):Object.keys(e);for(let a=0;a<r.length;++a){const i=r[a],c=Array.isArray(e)?e[a].tensor:e[i];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${i}': ${c.dtype}`);const l={name:i,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const f=new Promise(async u=>{const h=await c.bytes(),m=h.reduce((y,w)=>y+w.length,0)+Y*h.length,p=new Uint8Array(m);let d=0;for(let y=0;y<h.length;y++){const w=h[y],x=new Uint8Array(new Uint32Array([w.length]).buffer);p.set(x,d),d+=Y,p.set(w,d),d+=w.length}u(p)});s.push(f)}else s.push(c.data());t!=null&&(l.group=t),n.push(l)}const o=await Promise.all(s);return{data:kr(o),specs:n}}function kl(e,t){const n=new it(e),s={};let r=0;for(const o of t){const a=wr(o,(i,c)=>n.slice(r+i,r+c));s[o.name]=pn(o,n.slice(r,r+a)),r+=a}return s}function wr(e,t){const n=C(e.shape);let s;if("quantization"in e){const r=e.quantization;s=St[r.dtype]}else if(e.dtype==="string"){let r=0;for(let o=0;o<n;o++)r+=Y+new Uint32Array(t(r,r+Y))[0];return r}else s=St[e.dtype];return n*s}async function Sr(e,t){const n=C(e.shape);let s;if("quantization"in e){const r=e.quantization;s=St[r.dtype]}else if(e.dtype==="string"){let r=0;for(let o=0;o<n;o++)r+=Y+new Uint32Array(await t(r,r+Y))[0];return r}else s=St[e.dtype];return n*s}function pn(e,t){const n=e.name,s=e.dtype,r=e.shape,o=C(r);let a,i=0;if("quantization"in e){const c=e.quantization;if(c.dtype==="uint8"||c.dtype==="uint16"){if(!("min"in c&&"scale"in c))throw new Error(`Weight ${e.name} with quantization ${c.dtype} doesn't have corresponding metadata min and scale.`)}else if(c.dtype==="float16"){if(s!=="float32")throw new Error(`Weight ${e.name} is quantized with ${c.dtype} which only supports weights of type float32 not ${s}.`)}else throw new Error(`Weight ${e.name} has unknown quantization dtype ${c.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const l=St[c.dtype],f=c.dtype==="uint8"?new Uint8Array(t):new Uint16Array(t);if(s==="float32")if(c.dtype==="uint8"||c.dtype==="uint16"){a=new Float32Array(f.length);for(let u=0;u<f.length;u++){const h=f[u];a[u]=h*c.scale+c.min}}else if(c.dtype==="float16")a=vr()(f);else throw new Error(`Unsupported quantization type ${c.dtype} for weight type float32.`);else if(s==="int32"){if(c.dtype!=="uint8"&&c.dtype!=="uint16")throw new Error(`Unsupported quantization type ${c.dtype} for weight type int32.`);a=new Int32Array(f.length);for(let u=0;u<f.length;u++){const h=f[u];a[u]=Math.round(h*c.scale+c.min)}}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=o*l}else if(s==="string"){const c=C(e.shape);a=[];for(let l=0;l<c;l++){const f=new Uint32Array(t.slice(i,i+Y))[0];i+=Y;const u=new Uint8Array(t.slice(i,i+f));a.push(u),i+=f}}else{const c=St[s];if(s==="float32")a=new Float32Array(t);else if(s==="int32")a=new Int32Array(t);else if(s==="bool")a=new Uint8Array(t);else if(s==="complex64"){a=new Float32Array(t);const l=new Float32Array(a.length/2),f=new Float32Array(a.length/2);for(let p=0;p<l.length;p++)l[p]=a[p*2],f[p]=a[p*2+1];const u=se(l,r,"float32"),h=se(f,r,"float32"),m=gn(u,h);return u.dispose(),h.dispose(),m}else throw new Error(`Unsupported dtype in weight '${n}': ${s}`);i+=o*c}return se(a,r,s)}async function Ne(e,t,n){let s=new Uint8Array(t);for(;s.byteLength<n;){const{done:r,value:o}=await e.read();if(r&&o==null){const i=n-s.byteLength;throw new Error(`Reader is done but ${i} bytes are still expected`)}const a=new Uint8Array(s.length+o.byteLength);a.set(s,0),a.set(new Uint8Array(o),s.length),s=a}return s.buffer}async function Il(e,t){const n={},s=e.getReader();let r=new ArrayBuffer(0);for(const o of t){const a=await Sr(o,async(l,f)=>(r=await Ne(s,r,f),r.slice(l,f)));r=await Ne(s,r,a);const i=r.slice(0,a);r=r.slice(a);const c=pn(o,i);if(n[o.name]=c,yr()==="webgpu"){const l=br();"uploadToGPU"in l&&C(c.shape)>=S().get("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD")&&l.uploadToGPU(c.dataId)}}return n}function kr(e){if(e===null)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(o=>{if(t+=o.byteLength,n.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});const s=new Uint8Array(t);let r=0;return n.forEach(o=>{s.set(new Uint8Array(o.buffer),r),r+=o.byteLength}),s.buffer}const Te=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function Ce(e){return Te?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function Ir(e){if(Te)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let s=0,r=t.length;s<r;s++)n+=String.fromCharCode(t[s]);return btoa(n)}function Ar(e){if(Te){const s=Buffer.from(e,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let s=0;s<t.length;++s)n.set([t.charCodeAt(s)],s);return n.buffer}function Al(e){return it.join(e)}function Tl(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const n=e.split("/");return n[n.length-1]}function El(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return e.signature!=null&&(n.signature=e.signature),e.userDefinedMetadata!=null&&(n.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(n.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(n.initializerSignature=e.initializerSignature),e.trainingConfig!=null&&(n.trainingConfig=e.trainingConfig),n}function Tr(e,t,n){const s={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(e.trainingConfig!=null&&(s.trainingConfig=e.trainingConfig),e.weightsManifest!=null){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=t,s.weightData=n}return e.signature!=null&&(s.signature=e.signature),e.userDefinedMetadata!=null&&(s.userDefinedMetadata=e.userDefinedMetadata),e.modelInitializer!=null&&(s.modelInitializer=e.modelInitializer),e.initializerSignature!=null&&(s.initializerSignature=e.initializerSignature),s}async function xl(e,t){let n,s;return e.weightsManifest!=null&&([n,s]=await t(e.weightsManifest)),Tr(e,n,s)}function yn(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:e.modelTopology==null?0:Ce(JSON.stringify(e.modelTopology)),weightSpecsBytes:e.weightSpecs==null?0:Ce(JSON.stringify(e.weightSpecs)),weightDataBytes:e.weightData==null?0:new it(e.weightData).byteLength}}function Ml(e){const t=[];for(const n of e)t.push(...n.weights);return t}function Er(){const e=n=>{let s=n<<13,r=0;for(;(s&8388608)===0;)r-=8388608,s<<=1;return s&=-8388609,r+=947912704,s|r},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function xr(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function Mr(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function vr(){const e=Er(),t=xr(),n=Mr();return s=>{const r=new ArrayBuffer(4*s.length),o=new Uint32Array(r);for(let a=0;a<s.length;a++){const i=s[a],c=e[n[i>>10]+(i&1023)]+t[i>>10];o[a]=c}return new Float32Array(r)}}class M{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return M.instance==null&&(M.instance=new M),M.instance}static registerSaveRouter(t){M.getInstance().saveRouters.push(t)}static registerLoadRouter(t){M.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return M.getHandlers(t,"save")}static getLoadHandlers(t,n){return M.getHandlers(t,"load",n)}static getHandlers(t,n,s){const r=[];return(n==="load"?M.getInstance().loadRouters:M.getInstance().saveRouters).forEach(a=>{const i=a(t,s);i!==null&&r.push(i)}),r}}const vl=e=>M.registerSaveRouter(e),$l=e=>M.registerLoadRouter(e),Bl=e=>M.getSaveHandlers(e),Dl=(e,t)=>M.getLoadHandlers(e,t);const de="tensorflowjs",ge=1,nt="models_store",H="model_info_store";function bn(){if(!S().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e=typeof window>"u"?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function me(e){const t=e.result;t.createObjectStore(nt,{keyPath:"modelPath"}),t.createObjectStore(H,{keyPath:"modelPath"})}class rt{constructor(t){if(this.indexedDB=bn(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,n){return new Promise((s,r)=>{const o=this.indexedDB.open(de,ge);o.onupgradeneeded=()=>me(o),o.onsuccess=()=>{const a=o.result;if(n==null){const i=a.transaction(nt,"readonly"),l=i.objectStore(nt).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=f=>(a.close(),r(l.error)),i.oncomplete=()=>a.close()}else{n.weightData=it.join(n.weightData);const i=yn(n),c=a.transaction(H,"readwrite");let l=c.objectStore(H),f;try{f=l.put({modelPath:this.modelPath,modelArtifactsInfo:i})}catch(h){return r(h)}let u;f.onsuccess=()=>{u=a.transaction(nt,"readwrite");const h=u.objectStore(nt);let m;try{m=h.put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:i})}catch(p){return r(p)}m.onsuccess=()=>s({modelArtifactsInfo:i}),m.onerror=p=>{l=c.objectStore(H);const d=l.delete(this.modelPath);d.onsuccess=()=>(a.close(),r(m.error)),d.onerror=y=>(a.close(),r(m.error))}},f.onerror=h=>(a.close(),r(f.error)),c.oncomplete=()=>{u==null?a.close():u.oncomplete=()=>a.close()}}},o.onerror=a=>r(o.error)})}}rt.URL_SCHEME="indexeddb://";const wn=e=>S().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(rt.URL_SCHEME)?$r(e.slice(rt.URL_SCHEME.length)):null;M.registerSaveRouter(wn);M.registerLoadRouter(wn);function $r(e){return new rt(e)}function Br(e){return e.startsWith(rt.URL_SCHEME)?e.slice(rt.URL_SCHEME.length):e}class Dr{constructor(){this.indexedDB=bn()}async listModels(){return new Promise((t,n)=>{const s=this.indexedDB.open(de,ge);s.onupgradeneeded=()=>me(s),s.onsuccess=()=>{const r=s.result,o=r.transaction(H,"readonly"),i=o.objectStore(H).getAll();i.onsuccess=()=>{const c={};for(const l of i.result)c[l.modelPath]=l.modelArtifactsInfo;t(c)},i.onerror=c=>(r.close(),n(i.error)),o.oncomplete=()=>r.close()},s.onerror=r=>n(s.error)})}async removeModel(t){return t=Br(t),new Promise((n,s)=>{const r=this.indexedDB.open(de,ge);r.onupgradeneeded=()=>me(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(H,"readwrite"),i=a.objectStore(H),c=i.get(t);let l;c.onsuccess=()=>{if(c.result==null)return o.close(),s(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{const f=i.delete(t),u=()=>{l=o.transaction(nt,"readwrite");const m=l.objectStore(nt).delete(t);m.onsuccess=()=>n(c.result.modelArtifactsInfo),m.onerror=p=>s(c.error)};f.onsuccess=u,f.onerror=h=>(u(),o.close(),s(c.error))}},c.onerror=f=>(o.close(),s(c.error)),a.oncomplete=()=>{l==null?o.close():l.oncomplete=()=>o.close()}},r.onerror=o=>s(r.error)})}}const V="/",ht="tensorflowjs_models",Sn="info",Rr="model_topology",Fr="weight_specs",Nr="weight_data",Cr="model_metadata";function kn(e){return{info:[ht,e,Sn].join(V),topology:[ht,e,Rr].join(V),weightSpecs:[ht,e,Fr].join(V),weightData:[ht,e,Nr].join(V),modelMetadata:[ht,e,Cr].join(V)}}function In(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function Pr(e){const t=e.split(V);if(t.length<3)throw new Error(`Invalid key format: ${e}`);return t.slice(1,t.length-1).join(V)}function _r(e){return e.startsWith(ot.URL_SCHEME)?e.slice(ot.URL_SCHEME.length):e}class ot{constructor(t){if(!S().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=kn(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(t.modelTopology),s=JSON.stringify(t.weightSpecs),r=yn(t),o=it.join(t.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,Ir(o));const a={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,signature:t.signature!=null?t.signature:void 0,userDefinedMetadata:t.userDefinedMetadata!=null?t.userDefinedMetadata:void 0,modelInitializer:t.modelInitializer!=null?t.modelInitializer:void 0,initializerSignature:t.initializerSignature!=null?t.initializerSignature:void 0,trainingConfig:t.trainingConfig!=null?t.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:r}}catch{throw In(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=r;const o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){const i=JSON.parse(o);n.format=i.format,n.generatedBy=i.generatedBy,n.convertedBy=i.convertedBy,i.signature!=null&&(n.signature=i.signature),i.userDefinedMetadata!=null&&(n.userDefinedMetadata=i.userDefinedMetadata),i.modelInitializer!=null&&(n.modelInitializer=i.modelInitializer),i.initializerSignature!=null&&(n.initializerSignature=i.initializerSignature),i.trainingConfig!=null&&(n.trainingConfig=i.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Ar(a),n}}ot.URL_SCHEME="localstorage://";const An=e=>S().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(ot.URL_SCHEME)?Lr(e.slice(ot.URL_SCHEME.length)):null;M.registerSaveRouter(An);M.registerLoadRouter(An);function Lr(e){return new ot(e)}class Or{constructor(){b(S().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),b(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const t={},n=ht+V,s=V+Sn;for(let r=0;r<this.LS.length;++r){const o=this.LS.key(r);if(o.startsWith(n)&&o.endsWith(s)){const a=Pr(o);t[a]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=_r(t);const n=kn(t);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${t}'`);const s=JSON.parse(this.LS.getItem(n.info));return In(n),s}}const gt="://";class F{constructor(){this.managers={}}static getInstance(){return F.instance==null&&(F.instance=new F),F.instance}static registerManager(t,n){b(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(gt)&&(t=t.slice(0,t.indexOf(gt))),b(t.length>0,()=>"scheme must not be an empty string.");const s=F.getInstance();b(s.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),s.managers[t]=n}static getManager(t){const n=F.getInstance().managers[t];if(n==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return n}static getSchemes(){return Object.keys(F.getInstance().managers)}}function _t(e){if(e.indexOf(gt)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${F.getSchemes().join(",")}`);return{scheme:e.split(gt)[0],path:e.split(gt)[1]}}async function Tn(e,t,n=!1){b(e!==t,()=>`Old path and new path are the same: '${e}'`);const s=M.getLoadHandlers(e);b(s.length>0,()=>`Copying failed because no load handler is found for source URL ${e}.`),b(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${e}.`);const r=s[0],o=M.getSaveHandlers(t);b(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),b(o.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${t}.`);const a=o[0],i=_t(e).scheme,c=_t(e).path,l=i===_t(e).scheme,f=await r.load();n&&l&&await F.getManager(i).removeModel(c);const u=await a.save(f);return n&&!l&&await F.getManager(i).removeModel(c),u.modelArtifactsInfo}async function Rl(){const e=F.getSchemes(),t={};for(const n of e){const s=await F.getManager(n).listModels();for(const r in s){const o=n+gt+r;t[o]=s[r]}}return t}async function Fl(e){const t=_t(e);return F.getManager(t.scheme).removeModel(t.path)}async function Nl(e,t){return Tn(e,t,!1)}async function Cl(e,t){return Tn(e,t,!0)}class Ur{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(t,n){return fetch(t,n)}now(){return performance.now()}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,n){return new TextDecoder(n).decode(t)}setTimeoutCustom(t,n){if(typeof window>"u"||!S().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(t,n);return}this.functionRefs.push(t),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const r=this.functionRefs[s.data.index];r(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(t){return tn(t)}}if(S().get("IS_BROWSER")){S().setPlatform("browser",new Ur);try{F.registerManager(ot.URL_SCHEME,new Or)}catch{}try{F.registerManager(rt.URL_SCHEME,new Dr)}catch{}}const Gr={importFetch:()=>require("node-fetch")};let re;class zr{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(t,n){return S().global.fetch!=null?S().global.fetch(t,n):(re==null&&(re=Gr.importFetch()),re(t,n))}now(){const t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(t)}decode(t,n){return t.length===0?"":new this.util.TextDecoder(n).decode(t)}isTypedArray(t){return this.util.types.isFloat32Array(t)||this.util.types.isInt32Array(t)||this.util.types.isUint8Array(t)||this.util.types.isUint8ClampedArray(t)}}S().get("IS_NODE")&&!S().get("IS_BROWSER")&&S().setPlatform("node",new zr);function pe(e,t="float32",n){return t=t||"float32",It(e),new tr(e,t,n)}function Wr(e,t){const n=k(e,"x","cast");if(!We(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&n.dtype!=="string"||t!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:n},r={dtype:t};return g.runKernel(Ze,s,r)}const zt=E({cast_:Wr});function jr(e){const n={x:k(e,"x","clone","string_or_numeric")};return g.runKernel(Qe,n)}const En=E({clone_:jr});function Vr(e,t=!1){console.log(e.toString(t))}un();const qr={buffer:pe,cast:zt,clone:En,print:Vr};nr(qr);function Kr(e,t){let n=k(e,"a","add"),s=k(t,"b","add");[n,s]=Z(n,s);const r={a:n,b:s};return g.runKernel(Ye,r)}const A=E({add_:Kr});function Hr(e,t){let n=k(e,"a","floorDiv"),s=k(t,"b","floorDiv");[n,s]=Z(n,s);const r={a:n,b:s};return g.runKernel(Is,r)}const Xr=E({floorDiv_:Hr});function Jr(e,t){let n=k(e,"a","div"),s=k(t,"b","div");if([n,s]=Z(n,s),n.dtype==="int32"&&s.dtype==="int32")return Xr(n,s);const r={a:n,b:s},o={};return g.runKernel(ws,r,o)}const W=E({div_:Jr});function Yr(e,t){let n=k(e,"a","mul"),s=k(t,"b","mul");[n,s]=Z(n,s);const r={a:n,b:s};return g.runKernel(Es,r)}const I=E({mul_:Yr});function Zr(e){const t=k(e,"x","abs");if(t.dtype==="complex64"){const n={x:t};return g.runKernel(bs,n)}else{const n={x:t};return g.runKernel(ps,n)}}const Qr=E({abs_:Zr});function Pl(e,t,n,s,r="NHWC",o){const a=e[3],i=[...t,a],c=oo(r);return xn(e,i,n,o,s,null,null,c)}function _l(e,t,n,s,r,o,a="channelsLast"){const[i,c]=$t(t);let l;if(a==="channelsLast")l=[i,c,e[3],e[3]];else if(a==="channelsFirst")l=[i,c,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return xn(e,l,n,s,r,o,!1,a)}function Ll(e,t,n,s,r,o,a="NDHWC"){const[i,c,l]=ye(t);let f,u;if(a==="NDHWC")u="channelsLast",f=[i,c,l,e[4],e[4]];else if(a==="NCDHW")u="channelsFirst",f=[i,c,l,e[1],e[1]];else throw new Error(`Unknown dataFormat ${a}`);return to(e,f,n,s,r,!1,u,o)}function xn(e,t,n,s,r,o,a=!1,i="channelsLast"){let[c,l,f,u]=[-1,-1,-1,-1];if(i==="channelsLast")[c,l,f,u]=e;else if(i==="channelsFirst")[c,u,l,f]=e;else throw new Error(`Unknown dataFormat ${i}`);const[h,m,,p]=t,[d,y]=$t(n),[w,x]=$t(s),v=mt(h,w),D=mt(m,x),{padInfo:R,outHeight:G,outWidth:q}=so(r,l,f,d,y,v,D,o,i),lt=a?p*u:p;let ut;return i==="channelsFirst"?ut=[c,lt,G,q]:i==="channelsLast"&&(ut=[c,G,q,lt]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:f,inChannels:u,outHeight:G,outWidth:q,outChannels:lt,padInfo:R,strideHeight:d,strideWidth:y,filterHeight:h,filterWidth:m,effectiveFilterHeight:v,effectiveFilterWidth:D,dilationHeight:w,dilationWidth:x,inShape:e,outShape:ut,filterShape:t}}function to(e,t,n,s,r,o=!1,a="channelsLast",i){let[c,l,f,u,h]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[c,l,f,u,h]=e;else if(a==="channelsFirst")[c,h,l,f,u]=e;else throw new Error(`Unknown dataFormat ${a}`);const[m,p,d,,y]=t,[w,x,v]=ye(n),[D,R,G]=ye(s),q=mt(m,D),lt=mt(p,R),ut=mt(d,G),{padInfo:Pn,outDepth:Xt,outHeight:Jt,outWidth:Yt}=ro(r,l,f,u,w,x,v,q,lt,ut,i),Zt=o?y*h:y;let Qt;return a==="channelsFirst"?Qt=[c,Zt,Xt,Jt,Yt]:a==="channelsLast"&&(Qt=[c,Xt,Jt,Yt,Zt]),{batchSize:c,dataFormat:a,inDepth:l,inHeight:f,inWidth:u,inChannels:h,outDepth:Xt,outHeight:Jt,outWidth:Yt,outChannels:Zt,padInfo:Pn,strideDepth:w,strideHeight:x,strideWidth:v,filterDepth:m,filterHeight:p,filterWidth:d,effectiveFilterDepth:q,effectiveFilterHeight:lt,effectiveFilterWidth:ut,dilationDepth:D,dilationHeight:R,dilationWidth:G,inShape:e,outShape:Qt,filterShape:t}}function eo(e,t,n,s,r){s==null&&(s=Mn(e,t,n));const o=e[0],a=e[1],i=Bt((o-t+2*s)/n+1,r),c=Bt((a-t+2*s)/n+1,r);return[i,c]}function no(e,t,n,s,r,o){r==null&&(r=Mn(e,t[0],s[0]));const a=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(a[i]=Bt((e[i]-t[i]+2*r)/s[i]+1,o));return a}function Mn(e,t,n,s=1){const r=mt(t,s);return Math.floor((e[0]*(n-1)-n+r)/2)}function $t(e){return typeof e=="number"?[e,e,e]:e.length===2?[e[0],e[1],1]:e}function ye(e){return typeof e=="number"?[e,e,e]:e}function mt(e,t){return t<=1?e:e+(e-1)*(t-1)}function so(e,t,n,s,r,o,a,i,c){let l,f,u;if(typeof e=="number"){l={top:e,bottom:e,left:e,right:e,type:e===0?"VALID":"NUMBER"};const m=eo([t,n],o,s,e,i);f=m[0],u=m[1]}else if(e==="same"){f=Math.ceil(t/s),u=Math.ceil(n/r);const h=Math.max(0,(f-1)*s+o-t),m=Math.max(0,(u-1)*r+a-n),p=Math.floor(h/2),d=h-p,y=Math.floor(m/2),w=m-y;l={top:p,bottom:d,left:y,right:w,type:"SAME"}}else if(e==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((t-o+1)/s),u=Math.ceil((n-a+1)/r);else if(typeof e=="object"){const h=c==="channelsLast"?e[1][0]:e[2][0],m=c==="channelsLast"?e[1][1]:e[2][1],p=c==="channelsLast"?e[2][0]:e[3][0],d=c==="channelsLast"?e[2][1]:e[3][1];l={top:h,bottom:m,left:p,right:d,type:h===0&&m===0&&p===0&&d===0?"VALID":"EXPLICIT"},f=Bt((t-o+h+m)/s+1,i),u=Bt((n-a+p+d)/r+1,i)}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:l,outHeight:f,outWidth:u}}function ro(e,t,n,s,r,o,a,i,c,l,f){let u,h,m,p;if(e==="valid"&&(e=0),typeof e=="number"){u={top:e,bottom:e,left:e,right:e,front:e,back:e,type:e===0?"VALID":"NUMBER"};const y=no([t,n,s,1],[i,c,l],1,[r,o,a],e,f);h=y[0],m=y[1],p=y[2]}else if(e==="same"){h=Math.ceil(t/r),m=Math.ceil(n/o),p=Math.ceil(s/a);const d=(h-1)*r+i-t,y=(m-1)*o+c-n,w=(p-1)*a+l-s,x=Math.floor(d/2),v=d-x,D=Math.floor(y/2),R=y-D,G=Math.floor(w/2),q=w-G;u={top:D,bottom:R,left:G,right:q,front:x,back:v,type:"SAME"}}else throw Error(`Unknown padding parameter: ${e}`);return{padInfo:u,outDepth:h,outHeight:m,outWidth:p}}function Bt(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error(`Unknown roundingMode ${t}`)}}function Pe(e){const[t,n,s]=$t(e);return t===1&&n===1&&s===1}function Ol(e,t){return Pe(e)||Pe(t)}function Ul(e){return $t(e).every(t=>t>0)}function oo(e){if(e==="NHWC")return"channelsLast";if(e==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${e}`)}function Gl(e,t,n){if(n!=null){if(typeof t=="string")throw Error(`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);if(typeof t=="number")b(Ot(t),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${t}.`);else if(typeof t=="object")t.forEach(s=>{s.forEach(r=>{b(Ot(r),()=>`Error in ${e}: pad must be an integer when using dimRoundingMode ${n} but got pad ${r}.`)})});else throw Error(`Error in ${e}: Unknown padding parameter: ${t}`)}}function ao(e,t){const s={x:k(e,"x","reshape","string_or_numeric")},r={shape:t};return g.runKernel($s,s,r)}const vn=E({reshape_:ao});function io(e){const n={x:k(e,"x","sigmoid","float32")};return g.runKernel(Ds,n)}const co=E({sigmoid_:io});function lo(e,t){let n=k(e,"broadcastTo","x");const s=n.shape;if(It(t),t.length<n.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${n.rank}.`);if(t.length>n.rank){const l=n.shape.slice();for(;l.length<t.length;)l.unshift(1);n=vn(n,l)}const r=n.shape,o=Array.from(t);for(let l=t.length-1;l>=0;l--)if(r[l]===t[l])o[l]=1;else if(n.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${t}].`);if(o.map((l,f)=>l>1?f:-1).filter(l=>l>=0).length===0)return En(n);const i={x:n},c={reps:o};return g.runKernel(Cs,i,c)}const zl=E({broadcastTo_:lo});function uo(e,t,n){It(e),n=n||Rt(t);const s={shape:e,value:t,dtype:n};return g.runKernel(ks,{},s)}function fo(e,t){const n=e.length,s=[];for(let r=0;r<n;r++){const o=n-1-r,a=e[o]||1;(t[t.length-1-r]||1)>1&&a===1&&s.unshift(o)}return s}function $n(e,t){const n=[];for(let s=0;s<t.length;s++){const r=e[e.length-s-1],o=t.length-s-1,a=t[o];(r==null||r===1&&a>1)&&n.unshift(o)}return n}function Bn(e,t){const n=Math.max(e.length,t.length),s=new Array(n);for(let r=0;r<n;r++){let o=e[e.length-r-1];o==null&&(o=1);let a=t[t.length-r-1];if(a==null&&(a=1),o===1)s[n-r-1]=a;else if(a===1)s[n-r-1]=o;else if(o!==a){const i=`Operands could not be broadcast together with shapes ${e} and ${t}.`;throw Error(i)}else s[n-r-1]=o}return s}const Wl=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:Bn,getBroadcastDims:fo,getReductionAxes:$n},Symbol.toStringTag,{value:"Module"}));function ho(e){const n={x:k(e,"x","zerosLike")};return g.runKernel(Ps,n)}const j=E({zerosLike_:ho});function go(e){const n={x:k(e,"x","elu","float32")};return g.runKernel(Ss,n)}const mo=E({elu_:go});function Dn(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function po(e,t,n){const s=e.length+t.length,r=[];let o=0,a=0;for(let i=0;i<s;i++)n.indexOf(i)===-1?r.push(e[o++]):r.push(t[a++]);return r}function jl(e,t){const n=[],s=e.length;for(let o=0;o<s;o++)t.indexOf(o)===-1&&n.push(e[o]);const r=t.map(o=>e[o]);return[n,r]}function Vl(e,t){const n=t.map(s=>1);return po(e,n,t)}function ql(e,t,n){b(Dn(t,n),()=>`${e} supports only inner-most axes for now. Got axes ${t} and rank-${n} input.`)}function Kl(e,t){if(Dn(e,t))return null;const n=[];for(let s=0;s<t;++s)e.indexOf(s)===-1&&n.push(s);return e.forEach(s=>n.push(s)),n}function Hl(e){return e.map((t,n)=>[n,t]).sort((t,n)=>t[1]-n[1]).map(t=>t[0])}function Xl(e,t){const n=[];for(let s=t-e;s<t;++s)n.push(s);return n}function yo(e,t){let n=k(e,"base","pow"),s=k(t,"exp","pow");[n,s]=Z(n,s);const r={a:n,b:s};return g.runKernel(xs,r)}const _e=E({pow_:yo});function at(e,t){if((U(e)&&t!=="string"||Array.isArray(e))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&U(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return mn(e,[],[],t)}function bo(e){const n={x:k(e,"x","sqrt","float32")};return g.runKernel(Rs,n)}const kt=E({sqrt_:bo});function wo(e){const t=k(e,"x","square"),n={};return g.runKernel("Square",{x:t},n)}const st=E({square_:wo});function So(e,t=null,n=!1){let s=k(e,"x","sum");s.dtype==="bool"&&(s=zt(s,"int32"));const r={x:s},o={axis:t,keepDims:n};return g.runKernel(Fs,r,o)}const ko=E({sum_:So});function Io(e,t=.2){const s={x:k(e,"x","leakyRelu")},r={alpha:t};return g.runKernel(As,s,r)}const Ao=E({leakyRelu_:Io});function Jl(e){return b(J(e),()=>"The f passed in grad(f) must be a function"),(t,n)=>{const s=k(t,"x","tf.grad","string_or_numeric"),r=n!=null?k(n,"dy","tf.grad"):null;return g.tidy(()=>{const{value:o,grads:a}=g.gradients(()=>e(s),[s],r);return r!=null&&Dt(o.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),Ht(a),a[0]})}}function Yl(e){return b(J(e),()=>"The f passed in grads(f) must be a function"),(t,n)=>{b(Array.isArray(t),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=hr(t,"args","tf.grads","string_or_numeric"),r=n!=null?k(n,"dy","tf.grads"):null;return g.tidy(()=>{const{value:o,grads:a}=g.gradients(()=>e(...s),s,r);return r!=null&&Dt(o.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ht(a),a})}}function Zl(e){return b(J(e),()=>"The f passed in valueAndGrad(f) must be a function"),(t,n)=>{b(t instanceof P,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),b(n==null||n instanceof P,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:r}=g.gradients(()=>e(t),[t],n);return Ht(s),{grad:s[0],value:r}}}function Ql(e){return b(J(e),()=>"The f passed in valueAndGrads(f) must be a function"),(t,n)=>{b(Array.isArray(t)&&t.every(r=>r instanceof P),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),b(n==null||n instanceof P,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=g.gradients(()=>e(...t),t,n);return n!=null&&Dt(s.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),Ht(s.grads),s}}function To(e,t){b(J(e),()=>"The f passed in variableGrads(f) must be a function"),b(t==null||Array.isArray(t)&&t.every(l=>l instanceof Gt),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const n=t!=null;if(!n){t=[];for(const l in g.registeredVariables)t.push(g.registeredVariables[l])}const s=n?t.filter(l=>!l.trainable):null,r=t.length;t=t.filter(l=>l.trainable),b(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${r} variables is trainable.`);const o=!0,{value:a,grads:i}=g.gradients(e,t,null,o);b(i.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),b(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const c={};return t.forEach((l,f)=>{i[f]!=null&&(c[l.name]=i[f])}),s?.forEach(l=>c[l.name]=null),{value:a,grads:c}}function tu(e){return g.customGrad(e)}function Ht(e){if(e.filter(n=>n==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}function Eo(e,t){let n=k(e,"a","sub"),s=k(t,"b","sub");[n,s]=Z(n,s);const r={a:n,b:s};return g.runKernel(Ns,r)}const pt=E({sub_:Eo});function xo(e,t){let n=k(e,"a","maximum"),s=k(t,"b","maximum");[n,s]=Z(n,s),n.dtype==="bool"&&(n=zt(n,"int32"),s=zt(s,"int32")),Bn(n.shape,s.shape);const r={a:n,b:s};return g.runKernel(Ts,r)}const Mo=E({maximum_:xo});function Le(e,t="float32"){if(It(e),t==="complex64"){const s=Le(e,"float32"),r=Le(e,"float32");return gn(s,r)}const n=Vt(C(e),t);return g.makeTensor(n,e,t)}function vo(e,t){const n=k(e,"x","prelu"),s=k(t,"alpha","prelu"),r={x:n,alpha:s};return g.runKernel(Ms,r)}const $o=E({prelu_:vo});function Bo(e){const n={x:k(e,"x","relu")};return g.runKernel(vs,n)}const Do=E({relu_:Bo});function Ro(e){const n={x:k(e,"x","relu6")};return g.runKernel(Bs,n)}const Fo=E({relu6_:Ro});function No(e,t=0){const s={x:k(e,"x","step")},r={alpha:t};return g.runKernel(_s,s,r)}const Co=E({step_:No});function Rn(e,t,n){const s=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${t.shape}, shape: ${e}, sliceDim: ${s}, and batchDim: ${r}.`;if(n.rank<r)throw new Error(o+` update.rank < ${r}. `);if(e.length<s+(n.rank-r))throw new Error(o+` Output shape length < ${s+(n.rank-r)}`);if(n.rank!==r+e.length-s)throw new Error(o+` update.rank != ${r+e.length-s}`);for(let a=0;a<r;++a)if(n.shape[a]!==t.shape[a])throw new Error(o+` updates.shape[${a}] (${n.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<n.rank-r;++a)if(n.shape[a+r]!==e[a+s])throw new Error(o+` updates.shape[${a+r}] (${n.shape[a+r]}) != shape[${a+r}] (${e[a+r]})`)}function Po(e,t,n){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(e.size===0)throw new Error(`Updates specified for empty output. updates shape: ${e.shape}`)}Rn(n,t,e)}function _o(e,t,n){const s=t.shape.length,r=s>1?t.shape[s-1]:1,o=n.length;let a=1;for(let u=r;u<o;++u)a*=n[u];const i=r<1?1:r,c=C(t.shape)/i,l=[...Ft(n.slice(0,r)),1],f=C(n);return{sliceRank:r,numUpdates:c,sliceSize:a,strides:l,outputSize:f}}const eu=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:_o,validateInput:Po,validateUpdateShape:Rn},Symbol.toStringTag,{value:"Module"}));function nu(e,t){const n=[];for(let o=0;o<t.length;o++)t[o]&&n.push(o);const s=pe(e,"int32"),r=pe([n.length,e.length],"int32");for(let o=0;o<n.length;o++){const a=s.indexToLoc(n[o]),i=o*e.length;r.values.set(a,i)}return r.toTensor()}function su(e,t,n){if(n==null||n==="linear")return e;if(n==="relu")return I(e,Co(t));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function ru(e,t){let n=t;const s=$n(e.shape,t.shape);return s.length>0&&(n=ko(n,s)),vn(n,e.shape)}function ou(e,t,n,s){if(t==="linear")return e;if(t==="relu")return Do(e);if(t==="elu")return mo(e);if(t==="relu6")return Fo(e);if(t==="prelu")return $o(e,n);if(t==="leakyrelu")return Ao(e,s);if(t==="sigmoid")return co(e);throw new Error(`Unknown fused activation ${t}.`)}const au=(e,t)=>!(e>0)||t==="linear";function Lo(e,t,n){const s=Oo(e,t,n),r=s<0?-(s+1):s;e.splice(r,0,t)}function Oo(e,t,n){return Go(e,t,n||Uo)}function Uo(e,t){return e>t?1:e<t?-1:0}function Go(e,t,n){let s=0,r=e.length,o=0,a=!1;for(;s<r;){o=s+(r-s>>>1);const i=n(t,e[o]);i>0?s=o+1:(r=o,a=!i)}return a?s:-s-1}function iu(e,t,n,s,r){return Ee(e,t,n,s,r,0)}function cu(e,t,n,s,r,o){return Ee(e,t,n,s,r,0,!1,o,!0)}function lu(e,t,n,s,r,o){return Ee(e,t,n,s,r,o,!0)}function Ee(e,t,n,s,r,o,a=!1,i=!1,c=!1){const l=[];for(let y=0;y<t.length;y++)t[y]>r&&l.push({score:t[y],boxIndex:y,suppressBeginIndex:0});l.sort(Oe);const f=o>0?-.5/o:0,u=[],h=[];for(;u.length<n&&l.length>0;){const y=l.pop(),{score:w,boxIndex:x,suppressBeginIndex:v}=y;if(w<r)break;let D=!1;for(let R=u.length-1;R>=v;--R){const G=zo(e,x,u[R]);if(G>=s){D=!0;break}if(y.score=y.score*Wo(s,f,G),y.score<=r)break}y.suppressBeginIndex=u.length,D||(y.score===w?(u.push(x),h.push(y.score)):y.score>r&&Lo(l,y,Oe))}const m=u.length,p=n-m;i&&p>0&&(u.push(...new Array(p).fill(0)),h.push(...new Array(p).fill(0)));const d={selectedIndices:u};return a&&(d.selectedScores=h),c&&(d.validOutputs=m),d}function zo(e,t,n){const s=e.subarray(t*4,t*4+4),r=e.subarray(n*4,n*4+4),o=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),i=Math.max(s[0],s[2]),c=Math.max(s[1],s[3]),l=Math.min(r[0],r[2]),f=Math.min(r[1],r[3]),u=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),m=(i-o)*(c-a),p=(u-l)*(h-f);if(m<=0||p<=0)return 0;const d=Math.max(o,l),y=Math.max(a,f),w=Math.min(i,u),x=Math.min(c,h),v=Math.max(w-d,0)*Math.max(x-y,0);return v/(m+p-v)}function Wo(e,t,n){const s=Math.exp(t*n*n);return n<=e?s:0}function Oe(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const jo=new Map,be=new Map;class Fn{getClassName(){return this.constructor.className}static fromConfig(t,n){return new t(n)}}class K{constructor(){this.classNameMap={}}static getMap(){return K.instance==null&&(K.instance=new K),K.instance}static register(t){K.getMap().classNameMap[t.className]=[t,t.fromConfig]}}function Nn(e,t,n){b(e.className!=null,()=>"Class being registered does not have the static className property defined."),b(typeof e.className=="string",()=>"className is required to be a string, but got type "+typeof e.className),b(e.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof t>"u"&&(t="Custom"),typeof n>"u"&&(n=e.className);const s=n,r=t+">"+s;return K.register(e),jo.set(r,e),be.set(e,r),e}function Vo(e){return be.has(e)?be.get(e):e.className}const uu=Object.freeze(Object.defineProperty({__proto__:null,Serializable:Fn,SerializationMap:K,getRegisteredName:Vo,registerClass:Nn},Symbol.toStringTag,{value:"Module"}));class ct extends Fn{minimize(t,n=!1,s){const{value:r,grads:o}=this.computeGradients(t,s);if(s!=null){const a=s.map(i=>({name:i.name,tensor:o[i.name]}));this.applyGradients(a)}else this.applyGradients(o);return O(o),n?r:(r.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,n){return To(t,n)}dispose(){this.iterations_!=null&&O(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:at(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}}Object.defineProperty(ct,Symbol.hasInstance,{value:e=>e.minimize!=null&&e.computeGradients!=null&&e.applyGradients!=null});class qo extends ct{static get className(){return"Adadelta"}constructor(t,n,s=null){super(),this.learningRate=t,this.rho=n,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=g.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const o=g.registeredVariables[s],a=!1;this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accum_grad`,variable:B(()=>j(o).variable(a))}),this.accumulatedUpdates[r]==null&&(this.accumulatedUpdates[r]={originalName:`${s}/accum_var`,variable:B(()=>j(o).variable(a))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const c=this.accumulatedGrads[r].variable,l=this.accumulatedUpdates[r].variable;B(()=>{const f=A(I(c,this.rho),I(st(i),1-this.rho)),u=I(W(kt(A(l,this.epsilon)),kt(A(c,this.epsilon))),i),h=A(I(l,this.rho),I(st(u),1-this.rho));c.assign(f),l.assign(h);const m=A(I(u,-this.learningRate),o);o.assign(m)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(O(this.accumulatedGrads.map(t=>t.variable)),O(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){const t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=t.length/2,s=!1;this.accumulatedGrads=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedUpdates=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.rho,n.epsilon)}}class Ko extends ct{static get className(){return"Adagrad"}constructor(t,n=.1){super(),this.learningRate=t,this.initialAccumulatorValue=n,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const o=g.registeredVariables[s];this.accumulatedGrads[r]==null&&(this.accumulatedGrads[r]={originalName:`${s}/accumulator`,variable:B(()=>uo(o.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(t)?t[r].tensor:t[s];if(a==null)return;const i=this.accumulatedGrads[r].variable;B(()=>{const c=A(i,st(a));i.assign(c);const l=A(I(W(a,kt(A(c,g.backend.epsilon()))),-this.learningRate),o);o.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&O(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulatedGrads=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,n){return new t(n.learningRate,n.initialAccumulatorValue)}}class Ho extends ct{static get className(){return"Adam"}constructor(t,n,s,r=null){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],B(()=>{this.accBeta1=at(n).variable(),this.accBeta2=at(s).variable()}),r==null&&(this.epsilon=g.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);B(()=>{const s=pt(1,this.accBeta1),r=pt(1,this.accBeta2);n.forEach((o,a)=>{const i=g.registeredVariables[o],c=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:B(()=>j(i).variable(c))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:B(()=>j(i).variable(c))});const l=Array.isArray(t)?t[a].tensor:t[o];if(l==null)return;const f=this.accumulatedFirstMoment[a].variable,u=this.accumulatedSecondMoment[a].variable,h=A(I(f,this.beta1),I(l,1-this.beta1)),m=A(I(u,this.beta2),I(st(l),1-this.beta2)),p=W(h,s),d=W(m,r);f.assign(h),u.assign(m);const y=A(I(W(p,A(kt(d),this.epsilon)),-this.learningRate),i);i.assign(y)}),this.accBeta1.assign(I(this.accBeta1,this.beta1)),this.accBeta2.assign(I(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&O(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&O(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t),B(()=>{this.accBeta1.assign(_e(this.beta1,this.iterations_+1)),this.accBeta2.assign(_e(this.beta2,this.iterations_+1))});const n=t.length/2,s=!1;this.accumulatedFirstMoment=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedSecondMoment=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon)}}class Xo extends ct{static get className(){return"Adamax"}constructor(t,n,s,r=null,o=0){super(),this.learningRate=t,this.beta1=n,this.beta2=s,this.epsilon=r,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],B(()=>{this.iteration=at(0).variable(),this.accBeta1=at(n).variable()}),r==null&&(this.epsilon=g.backend.epsilon())}applyGradients(t){const n=Array.isArray(t)?t.map(s=>s.name):Object.keys(t);B(()=>{const s=pt(1,this.accBeta1),r=W(-this.learningRate,A(I(this.iteration,this.decay),1));n.forEach((o,a)=>{const i=g.registeredVariables[o],c=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:j(i).variable(c)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:j(i).variable(c)});const l=Array.isArray(t)?t[a].tensor:t[o];if(l==null)return;const f=this.accumulatedFirstMoment[a].variable,u=this.accumulatedWeightedInfNorm[a].variable,h=A(I(f,this.beta1),I(l,1-this.beta1)),m=I(u,this.beta2),p=Qr(l),d=Mo(m,p);f.assign(h),u.assign(d);const y=A(I(W(r,s),W(h,A(d,this.epsilon))),i);i.assign(y)}),this.iteration.assign(A(this.iteration,1)),this.accBeta1.assign(I(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&O(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&O(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,n){return new t(n.learningRate,n.beta1,n.beta2,n.epsilon,n.decay)}}class Cn extends ct{static get className(){return"SGD"}constructor(t){super(),this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const o=Array.isArray(t)?t[r].tensor:t[s];if(o==null)return;const a=g.registeredVariables[s];B(()=>{const i=A(I(this.c,o),a);a.assign(i)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=pr(at(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,n){return new t(n.learningRate)}}class Jo extends Cn{static get className(){return"Momentum"}constructor(t,n,s=!1){super(t),this.learningRate=t,this.momentum=n,this.useNesterov=s,this.accumulations=[],this.m=at(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const o=g.registeredVariables[s];this.accumulations[r]==null&&(this.accumulations[r]={originalName:`${s}/momentum`,variable:B(()=>j(o).variable(!1))});const a=this.accumulations[r].variable,i=Array.isArray(t)?t[r].tensor:t[s];i!=null&&B(()=>{let c;const l=A(I(this.m,a),i);this.useNesterov?c=A(I(this.c,A(i,I(l,this.m))),o):c=A(I(this.c,l),o),a.assign(l),o.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&O(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=!1;this.accumulations=t.map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,n){return new t(n.learningRate,n.momentum,n.useNesterov)}}class Yo extends ct{static get className(){return"RMSProp"}constructor(t,n=.9,s=0,r=null,o=!1){if(super(),this.learningRate=t,this.decay=n,this.momentum=s,this.epsilon=r,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,r==null&&(this.epsilon=g.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(s=>s.name):Object.keys(t)).forEach((s,r)=>{const o=g.registeredVariables[s],a=!1;this.accumulatedMeanSquares[r]==null&&(this.accumulatedMeanSquares[r]={originalName:`${s}/rms`,variable:B(()=>j(o).variable(a))}),this.accumulatedMoments[r]==null&&(this.accumulatedMoments[r]={originalName:`${s}/momentum`,variable:B(()=>j(o).variable(a))}),this.accumulatedMeanGrads[r]==null&&this.centered&&(this.accumulatedMeanGrads[r]={originalName:`${s}/mg`,variable:B(()=>j(o).variable(a))});const i=Array.isArray(t)?t[r].tensor:t[s];if(i==null)return;const c=this.accumulatedMeanSquares[r].variable,l=this.accumulatedMoments[r].variable;B(()=>{const f=A(I(c,this.decay),I(st(i),1-this.decay));if(this.centered){const u=this.accumulatedMeanGrads[r].variable,h=A(I(u,this.decay),I(i,1-this.decay)),m=W(I(i,this.learningRate),kt(pt(f,A(st(h),this.epsilon)))),p=A(I(l,this.momentum),m);c.assign(f),u.assign(h),l.assign(p);const d=pt(o,p);o.assign(d)}else{const u=A(I(c,this.decay),I(st(i),1-this.decay)),h=A(I(l,this.momentum),W(I(i,this.learningRate),kt(A(u,this.epsilon))));c.assign(u),l.assign(h);const m=pt(o,h);o.assign(m)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&O(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&O(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&O(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){const t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(n=>({name:n.originalName,tensor:n.variable})))}async setWeights(t){t=await this.extractIterations(t);const n=this.centered?t.length/3:t.length/2,s=!1;this.accumulatedMeanSquares=t.slice(0,n).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.accumulatedMoments=t.slice(n,n*2).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=t.slice(n*2,n*3).map(r=>({originalName:r.name,variable:r.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,n){return new t(n.learningRate,n.decay,n.momentum,n.epsilon,n.centered)}}const Zo=[qo,Ko,Ho,Xo,Jo,Yo,Cn];function Qo(){for(const e of Zo)Nn(e)}Qo();export{Ca as $,na as A,Gl as B,ga as C,pa as D,g as E,hr as F,En as G,xa as H,ba as I,Pc as J,wa as K,ri as L,Sa as M,ka as N,Aa as O,Ta as P,uo as Q,Ea as R,mc as S,P as T,Ul as U,Ma as V,$a as W,Ba as X,Ra as Y,Fa as Z,Na as _,b as a,Oi as a$,Pa as a0,La as a1,Oa as a2,Ua as a3,Wa as a4,ja as a5,Bn as a6,Ya as a7,zl as a8,dc as a9,di as aA,gi as aB,mi as aC,pi as aD,Ot as aE,Ei as aF,yi as aG,bi as aH,Ui as aI,wc as aJ,tu as aK,wi as aL,Si as aM,ki as aN,C as aO,hc as aP,$i as aQ,Di as aR,Fi as aS,Ni as aT,It as aU,Le as aV,gn as aW,He as aX,Pi as aY,_i as aZ,Li as a_,j as aa,Ha as ab,Jn as ac,Ja as ad,vi as ae,Ci as af,Ge as ag,Vl as ah,Qr as ai,ko as aj,kt as ak,_e as al,at as am,st as an,Za as ao,Qa as ap,ti as aq,Cs as ar,pe as as,si as at,oi as au,ii as av,ci as aw,ui as ax,fi as ay,hi as az,A as b,zi as b$,Gi as b0,qi as b1,Vi as b2,Hi as b3,Sc as b4,_l as b5,Ji as b6,Yi as b7,Zi as b8,Qi as b9,Uc as bA,zc as bB,Gc as bC,nu as bD,Dt as bE,Oc as bF,rr as bG,uc as bH,Mc as bI,ai as bJ,ss as bK,se as bL,va as bM,au as bN,ou as bO,xn as bP,Kc as bQ,su as bR,Pe as bS,ru as bT,Ga as bU,za as bV,Hc as bW,qc as bX,_a as bY,ni as bZ,Vc as b_,tc as ba,ec as bb,nc as bc,ic as bd,cc as be,lc as bf,gc as bg,tr as bh,bc as bi,pc as bj,yc as bk,Ic as bl,ei as bm,li as bn,kc as bo,vc as bp,ns as bq,Ki as br,Dc as bs,Cc as bt,Hn as bu,hn as bv,mn as bw,Po as bx,fc as by,_c as bz,zt as c,Xo as c$,iu as c0,ji as c1,lu as c2,Wi as c3,cu as c4,oc as c5,sc as c6,Lc as c7,Do as c8,Ac as c9,$l as cA,vl as cB,Fl as cC,Me as cD,Ka as cE,jc as cF,dt as cG,dr as cH,mo as cI,Xr as cJ,Ao as cK,Mo as cL,$o as cM,Vr as cN,Fo as cO,Co as cP,pr as cQ,qt as cR,jt as cS,Ie as cT,U as cU,bt as cV,Cn as cW,Jo as cX,Yo as cY,Ho as cZ,qo as c_,Tc as ca,Ec as cb,xc as cc,Rc as cd,Fc as ce,Nc as cf,Bc as cg,xl as ch,Tl as ci,M as cj,S as ck,it as cl,El as cm,yn as cn,St as co,kl as cp,Ml as cq,Al as cr,Nl as cs,Il as ct,Sl as cu,Dl as cv,Tr as cw,Bl as cx,Rl as cy,Cl as cz,O as d,es as d$,Ko as d0,ps as d1,Ye as d2,$n as d3,ya as d4,ma as d5,Ia as d6,Ze as d7,bs as d8,Da as d9,Rs as dA,$c as dB,_s as dC,Ns as dD,Fs as dE,Ps as dF,Jc as dG,rn as dH,vt as dI,br as dJ,Fn as dK,K as dL,Nn as dM,qe as dN,ct as dO,Ue as dP,ul as dQ,Ae as dR,or as dS,qs as dT,Gn as dU,ea as dV,ll as dW,tt as dX,as as dY,ie as dZ,bl as d_,Kl as da,qa as db,Va as dc,Ss as dd,Xa as de,Is as df,Hl as dg,Qe as dh,As as di,Ai as dj,xi as dk,Ts as dl,Ri as dm,Bi as dn,jl as dp,Es as dq,xs as dr,Ms as ds,ws as dt,Bs as du,vs as dv,$s as dw,ac as dx,rc as dy,Ds as dz,W as e,po as e$,Ft as e0,Xl as e1,ql as e2,Vt as e3,Ll as e4,oo as e5,to as e6,on as e7,Pl as e8,we as e9,rl as eA,ol as eB,al as eC,il as eD,cl as eE,fl as eF,hl as eG,dl as eH,gl as eI,yr as eJ,ml as eK,pl as eL,yl as eM,wl as eN,ve as eO,oe as eP,Yc as eQ,Zc as eR,Qc as eS,ys as eT,Ii as eU,Ti as eV,Mi as eW,Xi as eX,Wc as eY,os as eZ,Dn as e_,cs as ea,Kt as eb,is as ec,js as ed,ks as ee,Rt as ef,ls as eg,_o as eh,Wn as ei,Ls as ej,uu as ek,tl as el,Wl as em,nl as en,eu as eo,sl as ep,Gt as eq,De as er,el as es,Jl as et,Yl as eu,Zl as ev,Ql as ew,To as ex,us as ey,Xe as ez,co as f,Mn as f0,fo as f1,Xc as f2,Rn as f3,rs as f4,Ws as f5,Lt as f6,Zn as f7,xt as f8,jn as f9,fr as fa,ts as fb,Vn as fc,Ut as fd,fn as fe,k as g,sa as h,Wt as i,ra as j,oa as k,aa as l,I as m,ia as n,E as o,ca as p,la as q,vn as r,pt as s,B as t,ua as u,fa as v,Z as w,da as x,ha as y,Ol as z};
